{"config":{"lang":["it"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Alv67 Electronic Maker's FAQ","text":"<p>Raccolta di appunti personali su:</p> <ul> <li>schede elettroniche e la loro programmazione</li> <li>predisposizione ed installazione di un prorpio Homeserver e vari servizi collegati</li> <li>utilizzo di servizi cloud (per lo pi\u00f9 gratuiti)</li> </ul>"},{"location":"#m5stack-core-fire","title":"M5Stack CORE Fire","text":"<p>M5Stack Core \u00e8 una serie di microcontrollori modulari e compatti basati principalmente su ESP32, progettati per rendere lo sviluppo di dispositivi IoT, interfacce utente e prototipi elettronici semplice e veloce. \u00c8 prodotta dalla societ\u00e0 M5Stack e fa parte dell\u2019ecosistema Core Series</p>"},{"location":"#caratteristiche-comuni","title":"\ud83d\udd27 Caratteristiche comuni","text":"<ul> <li>ESP32: MCU potente con Wi-Fi + Bluetooth integrati.</li> <li>Display integrato: tipicamente 320x240 pixel.</li> <li>Slot per moduli: compatibilit\u00e0 con moduli, unit\u00e0 e accessori M5Stack, grazie a connettori standard (Grove, BUS, etc).</li> <li>Batteria LiPo: integrata e ricaricabile via USB.</li> <li>Case modulare: impilabile per aggiungere moduli GPS, batterie, sensori, rel\u00e8, ecc.</li> </ul>"},{"location":"#i-miei-appunti","title":"\ud83d\uddd2\ufe0f I miei appunti","text":"<ul> <li>Programmazione scheda con Arduino IDE</li> </ul>"},{"location":"#raspberry-pi","title":"Raspberry PI","text":"<p>La Raspberry Pi \u00e8 una single-board computer (SBC) a basso costo e di piccole dimensioni, sviluppata dalla Raspberry Pi Foundation con lo scopo di promuovere l\u2019insegnamento dell\u2019informatica e della programmazione, ma oggi ampiamente usata anche in progetti industriali, domotici e maker.</p> <p>\u00c8 un mini computer completo, che pu\u00f2 essere collegato a un monitor, tastiera e mouse ed eseguire sistemi operativi basati su Linux (come Raspberry Pi OS) o anche Windows IoT. Offre una vasta gamma di porte di espansione per l\u2019elettronica e la robotica.</p>"},{"location":"#caratteristiche-principali-raspberry-pi-45-modello-standard","title":"\ud83d\udd27 Caratteristiche principali (Raspberry Pi 4/5, modello standard)","text":"<ul> <li>Processore: Quad-core o superiori (es. ARM Cortex-A72 o Cortex-A76).</li> <li>RAM: da 1 GB fino a 8 GB (LPDDR4 o LPDDR4X).</li> <li>Storage: microSD card o SSD tramite USB/PCIe.</li> <li>Porte USB: 2x USB 2.0, 2x USB 3.0.</li> <li>HDMI: fino a 2 uscite micro-HDMI (4K supportato).</li> <li>Ethernet: fino a Gigabit.</li> <li>Wi-Fi + Bluetooth: integrati (a partire dalla Pi 3).</li> <li>GPIO: 40 pin per collegare componenti elettronici (LED, sensori, motori, ecc.).</li> <li>Alimentazione: tramite USB-C (5V 3A o pi\u00f9).</li> </ul>"},{"location":"#i-miei-appunti_1","title":"\ud83d\uddd2\ufe0f I miei appunti","text":"<ul> <li>Installazione Raspberry Pi</li> <li>Home Assistant su Raspberry Pi</li> <li>Raspberry Pi 5 con NVMe</li> <li>Installa Proxmox su Raspberry Pi OS</li> </ul>"},{"location":"#homelab-homeserver","title":"Homelab &amp; Homeserver","text":"<p>Un HomeLab (da home laboratory) \u00e8 un ambiente di test, sperimentazione o apprendimento IT realizzato a casa. Pu\u00f2 variare da un semplice Raspberry Pi fino a rack interi con server, switch, storage e firewall.</p> <p>\u2733\ufe0f Obiettivi principali:</p> <ul> <li>Imparare sistemi operativi (Linux, Windows Server, BSD\u2026)</li> <li>Sperimentare con virtualizzazione (es. Proxmox, VMware, Hyper-V)</li> <li>Gestire container (Docker, Kubernetes)</li> <li>Simulare ambienti enterprise</li> <li>Fare test prima di applicare soluzioni in produzione</li> <li>Imparare rete, sicurezza, DevOps, ecc.</li> </ul> <p>Un HomeServer \u00e8 un server domestico usato per eseguire servizi utili nella vita di tutti i giorni. \u00c8 spesso parte di un HomeLab, ma pu\u00f2 anche esistere da solo con scopi pratici.</p> <p>\ud83d\udccc Funzioni tipiche di un HomeServer:</p> <ul> <li>File server / NAS: accesso remoto ai file, backup centralizzati</li> <li>Media server: Plex, Jellyfin, Emby</li> <li>Server web o app: per hosting personale</li> <li>Domotica: Home Assistant, MQTT, Zigbee2MQTT</li> <li>Pi-hole: blocco pubblicit\u00e0 e tracciamento a livello di rete</li> <li>VPN server: per accedere in sicurezza alla rete di casa</li> <li>Container e VM: per servizi isolati</li> <li>Git server, CI/CD, monitoraggio (Grafana, Prometheus)</li> </ul> <p>Come si pu\u00f2 ben capire tra Homelab e Homeserver il passo e breve e la differenza \u00e8 quasi solo filosofica.</p> <p>Per questo io faccio difficolt\u00e0 a distinguere le due categorie, quindi gli appunti che seguono si adattano ad entrambe le categorie.</p>"},{"location":"#i-miei-appunti_2","title":"\ud83d\uddd2\ufe0f I miei appunti","text":"<ul> <li>Installazione e configurazione server Pi-hole su Proxmox VE</li> </ul>"},{"location":"#servizi-cloud","title":"Servizi cloud","text":"<p>In questo paragrafo vengono raccolti appunti, esempi pratici e indicazioni relative all\u2019utilizzo, creazione e configurazione di servizi cloud, con particolare attenzione alle offerte gratuitamente accessibili tramite i piani Free Tier messi a disposizione dai principali fornitori (come AWS, Google Cloud, Azure, Oracle Cloud e altri). L\u2019obiettivo \u00e8 documentare esperienze e procedure utili per sperimentare e apprendere le tecnologie cloud senza costi iniziali, esplorando servizi come macchine virtuali, database gestiti, storage, funzioni serverless, monitoraggio e altro. Questa raccolta pu\u00f2 servire sia come riferimento personale che come base per futuri progetti o ambienti di test.</p>"},{"location":"#i-miei-appunti_3","title":"\ud83d\uddd2\ufe0f I miei appunti","text":"<ul> <li>Oracle Cloud Interface OCI free tier</li> <li>Installa Proxmox VE 8 su Oracle OCI (free tier)</li> <li>Installa Docker su Oracle OCI (free tier)</li> <li>Pubblicare l'accesso SSH tramite Cloudflare Tunnel (con autenticazione Cloudflare)</li> </ul>"},{"location":"RaspberryPI/","title":"RASPBERRY PI - Una guida all'uso","text":""},{"location":"RaspberryPI/#installazione-raspberry-pi","title":"INSTALLAZIONE RASPBERRY PI","text":"<p>[paragrafo editato il 2024-08-30]</p> <ol> <li>Scaricare Raspberry Pi Imager dal sito ufficiale Raspberry PI</li> <li>Utilizzando l'applicativo scaricato, selezionare l'immagine del sistema operativo che si vuole installare:    nel dubbio scegliere \"Raspberry PI OS\" <p>NOTA: in caso si intenda utilizzare in modo HEADLESS (senza monitor e tastiera) e preconfigurare il Wi-Fi, vedere il capitolo dedicato prima di procedere con la creazione dell'immagine.</p> </li> <li>Iserire la SD-CARD sul computer e selezionarla dall'applicativo e avviare la scrittura</li> <li>Inserire l'SD-CARD nel Raspberry PI, accendere ed aspettare fino a completo avvio</li> </ol> <p>A questo punto \u00e8 possibile collegare un monitor e una tastiera per poter utilizzare il sistema operativo.</p>"},{"location":"RaspberryPI/#predisposizione-alluso-headless","title":"Predisposizione all'uso Headless","text":"<p>Nel caso non si voglia, o non si possa, utilizzare tastiera, mouse e monitor, \u00e8 possibile effettuare una configurazione della connessione Wi-Fi seguendo una delle procedure seguenti.</p>"},{"location":"RaspberryPI/#metodo-automatico-tramite-applicazione-raspberry-pi-imager-consigliato","title":"Metodo automatico tramite applicazione Raspberry PI Imager (consigliato)","text":"<p>Il nuovo applicativo Raspberry PI Imager ha una funzionalit\u00e0 di personalizzazione.</p> <p>Prima di procedere alla scrittura della immagine sulla scheda SD viene presentato il seguente popup</p> <p></p> <p>Selezionando la voce <code>MODIFICA IMPOSTAZIONI</code> si accede al men\u00f9 di configurazione:</p> <p></p> <p>Qui \u00e8 possibile:</p> <ul> <li>personalizzare l'hostname</li> <li>creare un utente root personalizzato (sostituisce l'utente pi di default)</li> <li>preconfigurare il Wi-Fi, prelevando automaticamente la configurazione dal sistema operativo o   permettendo si inserirla manualmente</li> <li>impostare fuso orario e layout tastiera Da tab SERVIZI</li> <li>abilitare la connessione SSH con login tramite password o chiave pubblica</li> </ul>"},{"location":"RaspberryPI/#predisposizione-manuale-di-wi-fi-e-ssh-metodo-obsoleto","title":"Predisposizione manuale di Wi-Fi e SSH (metodo obsoleto)","text":"<p>Nel caso non si voglia, o non si possa, utilizzare tastiera, mouse e monitor, \u00e8 possibile effettuare una configurazione della connessione Wi-Fi seguendo la procedura seguente.</p> <ol> <li>inserire la SD-CARD appena configurata nel proprio computer. La formattazione prevede la presenza di una partizione <code>boot</code>    formattata in FAT32 e leggibile e scrivibile anche da computer con sistema operativo Windows o macOS</li> <li> <p>occorre creare un file di configurazione che sar\u00e0 poi installato nella cartella /etc/wpa_supplicant del SO Raspberry.    Il file da creare deve chiamarsi <code>wpa_supplicant.conf</code> con il seguente contenuto:</p> <p>```sh ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 country=IT</p> <p>network={     ssid=\"YOURSSID\"     psk=\"YOURPASSWORD\"     scan_ssid=1 } ```</p> <p>NOTA : sostituire <code>ssid</code> e <code>psk</code> con le credenziali della propria rete Wi-Fi</p> <p>ATTENZIONE : non lasciare spazi attorno al simbolo <code>=</code> in questo file, il sistema non lo ammette...</p> </li> <li> <p>copiare il file all'interno della partizione <code>boot</code> nell'SD-CARD. Alla prima accensione questo file sar\u00e0    automaticamente spostato nella cartella dedicata ed utilizzato dal sistema operativo.</p> </li> <li>Purtroppo di default il sistema Raspbian non attiva il protocollo SSH, ma esiste un modo veloce per farlo:    occorre creare un file nominato <code>SSH</code> (senza estensione) nella partizione <code>boot</code> della SDCARD.</li> </ol>"},{"location":"RaspberryPI/#headless-login","title":"Headless login","text":"<p>Ovvero Collegarsi al Raspberry senza utilizzo di Tastiera e Monitor</p> <p>E' possibile accedere alla console del sistema Raspberry da remoto senza l'uso della tastiera collegata.</p> <p>Sar\u00e0 necessario collegare la Ethernet del Raspberry alla propria rete locale, dotata di DHCP. Tramite protocollo ssh si potra connettersi al dispositivo.</p> <p>Seguire i seguenti passi:</p> <ol> <li>Scoprire quale indirizzo IP \u00e8 stato fornito al Raspberry. Per fare questo occorre o utilizzare un qualsiasi    tool di IP Scanner di rete oppure verificare il dato dal proprio Router.</li> </ol> <p>NOTA : di default la scheda si presenta in rete con hostname <code>raspberrypi</code> quindi potrebbe non essere necessario cercare l'IP e provare a raggiungere la scheda all'indirizzo <code>raspberry.local</code> (da MacOS o Linux)</p> <ol> <li> <p>Utilizzando un terminale SSH \u00e8 ora possibile accedere alla console del Raspberry     user: <code>pi</code> password: <code>raspberry</code></p> <p><code>sh ssh {indirizzo IP | hostname}</code></p> </li> <li> <p>Ora \u00e8 possibile accedere al men\u00f9 di configurazione da terminale di Raspbian:</p> <p><code>sh sudo raspi-config</code></p> </li> </ol>"},{"location":"RaspberryPI/#prime-operazioni-post-installazione","title":"PRIME OPERAZIONI POST INSTALLAZIONE","text":"<p>[paragrafo editato il 2023-05-07]</p> <p>NOTA: di seguito sono riportate alcune operazioni consigliate da eseguire al    termine dell'installazione del sistema.    Si fa riferimento all'articolo : inDomus: Le prime cose da fare dopo aver installato Raspberry Pi OS (Raspbian)</p> <p>Tutti i comandi che vengono qui di seguito elencati fanno riferimento al terminale interno di Raspbian OS, quindi, ad esempio, ad una connessione SSH.</p>"},{"location":"RaspberryPI/#primo-aggiornamento","title":"Primo aggiornamento","text":"<p>La prima cosa da fare \u00e8 aggiornare tutto il software:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade -y\nsudo apt autoremove -y\n</code></pre> <p>al termine conviene effettuare un riavvio:</p> <pre><code>sudo reboot\n</code></pre>"},{"location":"RaspberryPI/#personalizzazioni","title":"Personalizzazioni","text":"<p>Sempre collegandoci con SSH lanciare il programma di configurazione:</p> <pre><code>sudo raspi-config\n</code></pre> <p>Viene presentata l'interfaccia per la personalizzazione del sistema:</p> <p></p> <p>Di seguito viene riportata la lista delle configurazioni consigliate:</p>"},{"location":"RaspberryPI/#system-optionboot-auto-login","title":"[System Option]/[Boot / Auto Login]","text":"<p>Selezionare la modalit\u00e0 di avvio del sistema: si consiglia la voce: <code>Console</code></p>"},{"location":"RaspberryPI/#interface-optionvnc","title":"[Interface Option]/[VNC]","text":"<p>E' fortemente consigliato abilitare i servizi SSH e VNC. Sicuramente SSH \u00e8 gi\u00e0 abilitato se si \u00e8 seguita la procedura di installazione proposta. Il servizio VNC si abilita con la voce di men\u00f9 qui definita.</p>"},{"location":"RaspberryPI/#localization-options","title":"[Localization Options]","text":"<p>Qui \u00e8 possibile personalizzare la localizzazione in lingua del prodotto. Se non fatto durante l'installazione \u00e8 qui possibile configurare il layout di tastiera, la Timezone per l'ora e la nazione per le regole di trasmissione del Wi-Fi.</p> <p>ATTENZIONE : \u00e8 consigliato invece mantenere la lingua del sistema al    valore di default: <code>English</code> in quanto tutte le procedure fanno riferimento    ai termini inglesi.</p>"},{"location":"RaspberryPI/#riavvio","title":"Riavvio","text":"<p>Al termine della configurazione eseguire il riavvio come proposto dal sistema.</p>"},{"location":"RaspberryPI/#configurazione-del-file-di-swap","title":"Configurazione del file di SWAP","text":"<p>Si consiglia di ampliare la dimensione del file di SWAP per evitare eventuali futuri problemi di spazio insufficiente di memoria (RAM+Swap).</p> <p>Per farlo, eseguire da terminale il seguente comando per fermare il servizio di swap:</p> <pre><code>sudo dphys-swapfile swapoff\n</code></pre> <p>dopodich\u00e9 modificare il file di impostazione swap tramite il comando:</p> <pre><code>sudo nano /etc/dphys-swapfile\n</code></pre> <p>andando a modificare la chave \u201c<code>CONF_SWAPSIZE</code>\u201d come segue:</p> <pre><code>CONF_SWAPSIZE=1024\n</code></pre> <p>dopodich\u00e9 uscire salvando (<code>CTRL+X</code>, <code>y</code>, <code>invio</code>) e infine riavviare il servizio di swap tramite il comando:</p> <pre><code>sudo dphys-swapfile swapon\n</code></pre>"},{"location":"RaspberryPI/#keepalive-ssh","title":"Keepalive SSH","text":"<p>Per evitare che, in futuro, connessioni SSH possano cadere (\u201cbroken pipe\u201d) per inattivit\u00e0, consigliamo la configurazione che segue. Eseguire il seguente comando:</p> <pre><code>sudo nano /etc/ssh/sshd_config\n</code></pre> <p>posizionarsi in fondo al file e aggiungere:</p> <pre><code>ClientAliveInterval 300\nClientAliveCountMax 2\n</code></pre> <p>Uscire e salvare (<code>CTRL+X</code>, <code>y</code>, <code>invio</code>) e poi eseguire il seguente comando:</p> <p>sudo nano /etc/ssh/ssh_config e aggiungere in fondo (attenzione ai quattro spazi davanti):</p> <pre><code>ServerAliveInterval 30\n</code></pre> <p>Uscire e salvare (<code>CTRL+X</code>, <code>y</code>, <code>invio</code>). Infine, riavviare con un comando:</p> <pre><code>sudo reboot\n</code></pre>"},{"location":"RaspberryPI/#installazione-di-nodejs-su-raspberry-pi-zero-armv6l","title":"INSTALLAZIONE DI Node.js SU RASPBERRY PI ZERO (armv6l)","text":"<p>Purtroppo i build ufficiali delle ultime versioni di Node.js non sono compilati per la piattaforma hardware ARM v6 utilizzata su Raspberry PI zero.</p> <p>Per verificare la piattaforma usare il comando:</p> <pre><code>uname -m\n</code></pre> <ol> <li>scaricare il Node.js compilato per la piattaforma dai Unofficial builds del sito ufficiale di Node.js. Ad esempio il compilato della versione nodejs.14.17.1 per armv6 si trova qui</li> </ol> <p>Quindi scaricare il binario tramite il seguente comando</p> <p><code>sh    wget https://unofficial-builds.nodejs.org/download/release/v14.17.1/node-v14.17.1-linux-armv6l.tar.xz</code></p> <ol> <li> <p>scompattare l'archivio binario appena scaricato all'interno della cartella nella quale si intende installare Node.js, ad esempio in <code>/usr/local/lib/nodejs</code></p> <p>```sh sudo mkdir -p /usr/local/lib/nodejs</p> <p>sudo tar -xJvf node-v14.17.1-linux-armv6l.tar.xz -C /usr/local/lib/nodejs ```</p> </li> <li> <p>aggiungere il percorso alla variabile d'ambiente PATH. Editale il file <code>~/.profile</code> ed aggiungere:</p> <p>alternativamente \u00e8 possibile utilizzare il metodo spiegato al punto successivo</p> <p><code>sh export PATH=/usr/local/lib/nodejs/node-v14.17.1.linux-armv6l/bin:$PATH</code></p> <p>riavvia il profilo</p> <p><code>sh . ~/.profile</code></p> </li> <li> <p>creare i link simbolici</p> <p>metodo alternativo rispetto al punto precedente</p> <p>NOTA: alternativamente al questo metodo \u00e8 possibile creare dei link simbolici agli applicativi node, npm e npx direttamente all'interno di /usr/bin. In questo modo tutti gli utenti possono avere accesso a Node.js</p> <p>```sh sudo ln -s /usr/local/lib/nodejs/node-v14.17.1-linux-armv6l/bin/node /usr/bin/node</p> <p>sudo ln -s /usr/local/lib/nodejs/node-v14.17.1-linux-armv6l/bin/npm /usr/bin/npm</p> <p>sudo ln -s /usr/local/lib/nodejs/node-v14.17.1-linux-armv6l/bin/npx /usr/bin/npx ```</p> </li> <li> <p>test del corretto funzionamento di node, npm  e npx</p> <p>```sh node -v</p> <p>npm version</p> <p>npx -v ```</p> </li> </ol>"},{"location":"RaspberryPI/#installare-docker-su-raspberry-pi-os","title":"INSTALLARE DOCKER SU RASPBERRY PI OS","text":"<p>[paragrafo editato il 2023-05-07]</p> <p>Di seguito si fa uso della procedura automatica di installazione.</p>"},{"location":"RaspberryPI/#aggiornamento-del-sistema","title":"Aggiornamento del sistema","text":"<p>Per prima cosa, occorre effettuare un aggiornamento del sistema:</p> <pre><code>sudo apt-get update -y\nsudo apt-get upgrade -y\nsudo reboot\n</code></pre>"},{"location":"RaspberryPI/#installazione-automatica","title":"Installazione automatica","text":"<p>Successivamente al riavvio causato dall\u2019ultimo comando, installare tramite procedura automatica l\u2019ambiente di virtualizzazione Docker tramite il comando:</p> <pre><code>sudo curl -fsSL https://get.docker.com -o /tmp/get-docker.sh\nsudo chmod +x /tmp/get-docker.sh\nsudo sh /tmp/get-docker.sh\n</code></pre>"},{"location":"RaspberryPI/#aggiunta-dellutente-al-gruppo-docker","title":"Aggiunta dell'utente al gruppo <code>docker</code>","text":"<p>Questo autorizza l'utente ad eseguire direttamente i comandi <code>docker</code></p> <pre><code>sudo usermod -aG docker $USER\nsudo reboot\n</code></pre>"},{"location":"RaspberryPI/#verifica","title":"Verifica","text":"<p>Successivamente all\u2019avvenuta installazione e per verificare che Docker sia correttamente installato, eseguire il seguente comando:</p> <pre><code>docker run hello-world\n</code></pre> <p>Per confermare la bont\u00e0 dell\u2019installazione ed esecuzione di Docker, l\u2019output dev\u2019essere simile al seguente:</p> <pre><code>Unable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\n70f5ac315c5a: Pull complete\nDigest: sha256:9eabfcf6034695c4f6208296be9090b0a3487e20fb6a5cb056525242621cf73d\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (arm64v8)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre> <p>Per ora \u00e8 tutto</p> <p>alv67</p>"},{"location":"cloudflaressh/","title":"Pubblicare l'accesso SSH tramite Cloudflare Tunnel (con autenticazione Cloudflare)","text":"<p>Per accedere in modo sicuro al terminale SSH della tua istanza tramite un'interfaccia web, puoi utilizzare Cloudflare Tunnel e la funzionalit\u00e0 SSH Web Terminal di Cloudflare Access. Questo permette di esporre la porta SSH tramite un URL protetto, ad esempio <code>docker-oci.tuo-dominio.com</code>, e accessibile solo previa autenticazione Cloudflare.</p> <p>In questa guida si fa riferimento a un'istanza Ubuntu su Oracle Cloud Infrastructure (OCI) free tier, ma il processo \u00e8 simile per altre piattaforme cloud.</p>"},{"location":"cloudflaressh/#prerequisiti","title":"Prerequisiti","text":"<ul> <li>Un dominio gestito su Cloudflare (es: <code>tuo-dominio.com</code>)</li> <li>Accesso all'account Cloudflare e permessi per creare un tunnel e configurare Access</li> <li>Cloudflare Tunnel installato sulla VM</li> </ul>"},{"location":"cloudflaressh/#installare-cloudflare-tunnel-cloudflared","title":"Installare Cloudflare Tunnel (cloudflared)","text":"<p>Dal sito Cloudflare andare alla sezione \"Zero-Trust\" / \"Tunnels\"</p> <p>Poi selezionare la voce \"Create Tunnel\" e seguire le istruzioni.</p> <p></p>"},{"location":"cloudflaressh/#1-scegli-lambiente","title":"1. Scegli l'ambiente","text":"<p>Selezionare il sistema operativo in uso <code>Debian</code>e l'architettura <code>64-bit</code></p>"},{"location":"cloudflaressh/#2-installare-cloudflared","title":"2. Installare cloudflared","text":"<p>Per installare <code>cloudflared</code> su Ubuntu, copiare il codice proposto sul sito:</p> <pre><code># Add cloudflare gpg key\nsudo mkdir -p --mode=0755 /usr/share/keyrings\ncurl -fsSL https://pkg.cloudflare.com/cloudflare-main.gpg | sudo tee /usr/share/keyrings/cloudflare-main.gpg &gt;/dev/null\n\n# Add this repo to your apt repositories\necho 'deb [signed-by=/usr/share/keyrings/cloudflare-main.gpg] https://pkg.cloudflare.com/cloudflared any main' | sudo tee /etc/apt/sources.list.d/cloudflared.list\n\n# install cloudflared\nsudo apt-get update &amp;&amp; sudo apt-get install cloudflared\n</code></pre>"},{"location":"cloudflaressh/#3-attivare-il-servizio-cloudflared","title":"3. Attivare il servizio cloudflared","text":"<p>Come indicato sulla pagina copiare il comando ed eseguirlo. Attenzione il comando contiene un UUID che \u00e8 unico per ogni tunnel che non viene mostrato completamente a video, ma passato solo copiando il comando.</p> <p>Il comando sar\u00e0 simile al seguente:</p> <pre><code>sudo cloudflared service install ytrbgDFwsAQWcdfFSDGfdgfd.....\n</code></pre>"},{"location":"cloudflaressh/#4-verifica-attivazione-servizio","title":"4. Verifica attivazione servizio","text":"<p>Non appena il servizio sar\u00e0 attivo sulla pagina compare lo stato di connessione.</p>"},{"location":"cloudflaressh/#5-instrada-il-traffico","title":"5. Instrada il traffico","text":"<p>Premere il pulsante Successivo a fondo pagina per procedere alla configurazione del tunnel.</p> <p>Qui si configura il tunnel per instradare il traffico verso la porta SSH della tua istanza.</p> <ul> <li>Nome host</li> <li>Sottodominio : <code>docker-oci</code></li> <li>Dominio : <code>tuo-dominio.com</code></li> <li>Percorso : lasciare vuoto</li> <li>Servizio</li> <li>Tipo: <code>SSH</code></li> <li>URL: <code>localhost:22</code></li> </ul>"},{"location":"cloudflaressh/#6-configura-cloudflare-access-per-ssh-web-terminal","title":"6. Configura Cloudflare Access per SSH Web Terminal","text":"<ol> <li>Vai su Zero Trust \u2192 Access \u2192 Applicazioni \u2192 <code>+ Aggiungi un'applicazione</code>.</li> <li>Scegli Self-hosted.</li> <li>Nome Applicazione : <code>SSH Web Terminal</code>, Durata sessione: <code>24 hours</code></li> <li>Aggiungi nome host pubblico : Sottodominio: <code>docker-oci</code>, Dominio: <code>tuo-dominio.com</code></li> <li>Impostazioni di rendering del browser : scegli SSH</li> <li>Configura le policy di accesso (ad esempio, solo il tuo account email Cloudflare).</li> <li>Salva e attiva l'applicazione.</li> </ol> <p>Ora, accedendo a <code>https://docker-oci.tuo-dominio.com</code> da browser, Cloudflare ti chieder\u00e0 di autenticarti e ti presenter\u00e0 l\u2019interfaccia web del terminale SSH collegato alla tua istanza.</p>"},{"location":"cloudflaressh/#7-crea-una-chiave-ssh-per-laccesso-web","title":"7. Crea una chiave SSH per l'accesso web","text":"<p>Cloudflare richiede una chiave SSH protetta da password per autenticare l'accesso al terminale web. Puoi generare una chiave SSH con il seguente comando su di un terminale del tuo computer locale:</p> <pre><code>ssh-keygen -t ed25519 -f ~/.ssh/cloudflare_ssh_key -C \"cloudflare-ssh\" -N \"your_password\"\n</code></pre>"},{"location":"cloudflaressh/#8-aggiungi-la-chiave-pubblica-allistanza","title":"8. Aggiungi la chiave pubblica all'istanza","text":"<p>Ora copia la chiave pubblica generata (nel computer locale <code>~/.ssh/cloudflare_ssh_key.pub</code>) e aggiungila alla tua istanza come chiave autorizzata per l'utente <code>ubuntu</code> nel file <code>~/.ssh/authorized_keys</code>.</p> <p>E' possibile farlo direttamente dal tuo terminale locale con il comando:</p> <pre><code>ssh-copy-id -i ~/.ssh/cloudflare_ssh_key.pub ubuntu@[public.ip.address]\n</code></pre> <p>In alternativa, puoi copiare manualmente il contenuto della chiave pubblica nel file <code>~/.ssh/authorized_keys</code> dell'utente <code>ubuntu</code> sulla tua istanza.</p> <p>Al termine assicurati che il file <code>authorized_keys</code> abbia i permessi corretti:</p> <pre><code>chmod 600 ~/.ssh/authorized_keys\n</code></pre> <p>Per accedere al terminale web, dovrai utilizzare la chiave privata generata (<code>~/.ssh/cloudflare_ssh_key</code>) e ricordarti la password utilizzata in fase di creazione.</p>"},{"location":"cloudflaressh/#9-accedi-al-terminale-web","title":"9. Accedi al terminale web","text":"<p>Ora puoi accedere al terminale web SSH visitando <code>https://docker-oci.tuo-dominio.com</code> nel tuo browser.</p> <p>Se non gi\u00e0 effettuato a cloudflare, ti verr\u00e0 chiesto di autenticarti con il tuo account Cloudflare.</p> <p></p> <p>Una volta effettuato l'accesso verrai reindirizzato al terminale web SSH. La prima richiesta \u00e8 l'utente da utilizzare per l'accesso SSH, inserire <code>ubuntu</code> e premere Next.</p> <p></p> <p>Di seguito ti verr\u00e0 chiesto di inserire la chiave SSH privata e la password associata. Copia il contenuto della chiave privata generata (<code>~/.ssh/cloudflare_ssh_key</code>) e incollalo nel campo Private Key. Poi inserisci la password che hai scelto durante la generazione della chiave.</p> <p></p> <p>Se tutto \u00e8 andato a buon fine, dovresti vedere il terminale SSH della tua istanza.</p> <p></p> <p>Questa procedura ti permette di accedere in modo sicuro e protetto al terminale della tua istanza tramite browser, senza esporre direttamente la porta SSH su internet.</p>"},{"location":"dockeronoci/","title":"Predisponi server Docker su Oracle OCI (free tier)","text":"<p>[documento editato il 2025-07-26]</p> <p>Oracle nella piattaforma Oracle Cloud Infrastructure (OCI) mette a dispisizione un ottimo tier gratuito In questo tier sono disponibili risorse per creare instanze di macchine virtuali nel piano che viene indicato come always-free.</p> <p>In particolare si hanno a disposizione:</p> <ul> <li>due instanze AMD x86_64 con 1/8 OCPU (corrispondenti a 2 vCPU) e 1GB di RAM.</li> <li>una istanza ARM-based 4 core e 24 GB di RAM</li> </ul> <p>Inoltre si hanno a disposizione 200GB di blocco dati da utilizzare come memoria di massa. Siccome il minimo utilizzabile per ogni istanza \u00e8 pari a 49GB, alla fine si consiglia di utilizzare:</p> <ul> <li>100GB per la istanza ARM-Based</li> <li>50GB per ogni istanza AMD</li> </ul>"},{"location":"dockeronoci/#ubuntu-su-istanza-vmstandarda1flex","title":"Ubuntu su istanza VM.Standard.A1.Flex","text":"<p>Di seguito si riportano i passi necessari per la creazione dell'istanza gratuita.</p>"},{"location":"dockeronoci/#selezionare-creazione-di-compute-instance","title":"Selezionare creazione di Compute-Instance","text":"<p>Dal men\u00f9 principale di OCI selezionare la voce Compute-&gt;Instances</p> <p></p> <p>E dalla pagina che si presenta selezionare il pulsante Create Instance</p> <p></p>"},{"location":"dockeronoci/#1-creazione-dellistanza-basic-informations","title":"1. Creazione dell'istanza: Basic informations","text":"<p>Compilare il form con le informazioni richieste:</p> <ul> <li>Name: Nome dell'istanza, ad esempio <code>docker-oci</code></li> <li>Compartment: Il compartment in cui si vuole creare l'istanza.   Se \u00e8 la prima volta ci sar\u00e0 un solo compartment chiamato (root).</li> </ul> <p>Selezionare il sistema operativo: premere il pulsante Change image e selezionare la voce <code>Canonical Ubuntu 24.04</code>; premere Select image.</p> <p>Selezionare il tipo di istanza: quella proposta di default dovrebbe gi\u00e0 essere corretta, in ogni caso selezionare <code>VM.Standard.E2.1.Micro</code>.</p> <p>Premere Next per proseguire.</p>"},{"location":"dockeronoci/#2-security","title":"2. Security","text":"<p>Lasciare le opzioni di default e premere Next.</p>"},{"location":"dockeronoci/#3-networking","title":"3. Networking","text":"<p>Se \u00e8 gi\u00e0 stato creato un Virtual Cloud Network (VCN) si pu\u00f2 selezionare quello esistente, altrimenti si pu\u00f2 creare un nuovo VCN.</p> <p>Scegliere un nome per il VCN, ad esempio <code>docker-oci-vcn</code>.</p> <p>Se si crea un nuovo VCN spuntare Create a new virtual cloud network e lasciare le opzioni di default.</p> <p>Spuntare la voce Create a new public subnet e lasciare le opzioni di default.</p> <p>Sarebbe opportuno selezionare la voce Assign a public IPv4 address per poter accedere all'istanza da internet, ma se la subnet viene create con questa opzione, la voce pare non selezionabile</p> <p>!! MOLTO IMPORTANTE !!</p> <p>Occorre aggiungere una chiave SSH per poter accedere all'istanza una volta creata. Selezionare la voce Add SSH keys e incollare la chiave pubblica SSH generata in precedenza, o se non si ha c'\u00e8 la possibilit\u00e0 di generarla direttamente da questa pagina.</p> <p>NOTA</p> <p>senza una chiave SSH non sar\u00e0 possibile accedere all'istanza una volta creata.</p>"},{"location":"dockeronoci/#4-storage","title":"4. Storage","text":"<p>Occorre ora creare il disco di boot per l'istanza.</p> <p>Spuntare la voce Specify a custom boot volume size and performance settings</p> <p>Scegliere la dimensione del disco di boot, ad esempio 50GB.</p> <p></p> <p>NOTA.</p> <p>50GB \u00e8 il minimo richiesto per le istanze AMD. Nel piano free tier si hanno a disposizione un massimo di 200GB suddivisi tra le istanze.</p> <p>Lasciare le altre opzioni di default e premere Next.</p>"},{"location":"dockeronoci/#5-review-and-create","title":"5. Review and create","text":"<p>Vengono ora presentate le informazioni inserite, se tutto \u00e8 corretto premere il pulsante Create.</p> <p>Come si pu\u00f2 notare alla sezione Networking viene indicato che la subnet \u00e8 pubblica, e l'opzione Public IPv4 address \u00e8 impostata a Yes.</p>"},{"location":"dockeronoci/#attendere-la-creazione-dellistanza","title":"Attendere la creazione dell'istanza","text":"<p>Ora parte automaticamente la creazione dell'istanza, che pu\u00f2 richiedere qualche minuto.</p> <p>Al termine, selezionare dal men\u00f9 Instances l'istanza appena creata e dal tab Details si pu\u00f2 vedere l'indirizzo IP pubblico assegnato all'istanza e lo username.</p> <p>Possiamo ora provare a connetterci tramite SSH alla'istanza utilizzando l'indirizzo IP pubblico e lo username <code>ubuntu</code> e la chiave SSH precedentemente inserita.</p> <pre><code>ssh -i [path/to/your/private/key] ubuntu@[public.ip.address]\n</code></pre> <p>Se tutto \u00e8 andato a buon fine si dovrebbe essere connessi all'istanza.</p> <p></p> <p>Ora occorre assicurarsi di avere settato il firewall per permettere al traffico internet di raggiungere l'istanza.</p> <p>Connettersi all'istanza tramite connessioe SSH ed scaricare l'immagine necessaria per installare il da rete Proxmox:</p> <pre><code>sudo -i\ncd /boot/efi\nwget https://boot.netboot.xyz/ipxe/netboot.xyz-arm64.efi\n</code></pre>"},{"location":"dockeronoci/#configurare-ubuntu","title":"Configurare Ubuntu","text":"<p>Ora che l'istanza \u00e8 pronta, possiamo procedere con la configurazione di Ubuntu per l'utilizzo di Docker.</p>"},{"location":"dockeronoci/#aggiornare-il-sistema","title":"Aggiornare il sistema","text":"<p>La prima cosa da fare \u00e8 aggiornare il sistema operativo all'ultima versione disponibile.</p> <pre><code>sudo apt update &amp;&amp; sudo apt upgrade -y\n</code></pre> <p>Al termine dell'aggiornamento, \u00e8 consigliabile riavviare l'istanza per assicurarsi che tutte le modifiche abbiano effetto.</p> <pre><code>sudo reboot\n</code></pre>"},{"location":"dockeronoci/#creare-una-password-per-lutente-ubuntu","title":"Creare una password per l'utente <code>ubuntu</code>","text":"<p>La password non \u00e8 richiesta per l'utente <code>ubuntu</code> ma \u00e8 consigliabile impostarla per poter utilizzare la console messa a disposizione da OCI.</p> <pre><code>sudo passwd ubuntu\n</code></pre> <p>Alla richiesta inserire una password sicura e confermarla.</p>"},{"location":"dockeronoci/#installare-docker","title":"Installare Docker","text":"<p>Per installare Docker su Ubuntu, occorre predisporre il sistema con i certificati e il repository ufficiale di Docker.</p> <pre><code># Add Docker's official GPG key:\nsudo apt-get update\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n\n# Add the repository to Apt sources:\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release &amp;&amp; echo \"${UBUNTU_CODENAME:-$VERSION_CODENAME}\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n</code></pre> <p>A questo punto \u00e8 possibile effettuare l'installazione:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre>"},{"location":"dockeronoci/#abilitare-utente-corrente-per-lutilizzo-di-docker","title":"Abilitare utente corrente per l'utilizzo di Docker","text":"<p>Per poter utilizzare Docker senza dover utilizzare il comando <code>sudo</code>, \u00e8 necessario aggiungere l'utente corrente al gruppo <code>docker</code>.</p> <pre><code>sudo usermod -aG docker $USER\n</code></pre> <p>Dopo aver eseguito questo comando, \u00e8 necessario disconnettersi e riconnettersi per applicare le modifiche. Per verificare che tutto funzioni correttamente, \u00e8 possibile eseguire il comando:</p> <pre><code>docker run hello-world\n</code></pre> <p>Se tutto \u00e8 andato a buon fine, si dovrebbe vedere un messaggio di benvenuto da parte di Docker.</p>"},{"location":"dockeronoci/#ripulire-il-sistema","title":"Ripulire il sistema","text":"<p>Iniziamo ripulendo docker:</p> <pre><code>docker system prune -a --volumes\n</code></pre> <p>Proseguiamo ora con la pulizia del sistema:</p> <pre><code>sudo apt autoremove --purge -y\nsudo apt clean\nsudo rm -rf /var/lib/apt/lists/*\n</code></pre>"},{"location":"dockeronoci/#altre-ulteriori-configurazioni-opzionali","title":"Altre ulteriori configurazioni opzionali","text":"<p>Di seguito alcune configurazioni opzionali che possono essere utili:</p> <ul> <li>Pubblicare la porta SSH per l'accesso remoto tramite Cloudflare Tunnel</li> </ul>"},{"location":"homeassistant/","title":"Home Assistant su Raspberry Pi","text":"<p>[documento editato il 2024-06-28]</p> <p>Qui di seguito vengono riportate le procedure per l'installazione e la configurazione di un Hub personale per la domotica.</p> <p>A questo scopo si utilizzer\u00e0 una scheda Raspberry Pi 3 opportunamente configurata, sulla quale viene installato l'applicativo Home Assistant.</p> <p>Come sito di riferimento per le procedure di installazione e configurazione si consiglia InDomus, una comunit\u00e0 dedicata alla domotica personale.</p>"},{"location":"homeassistant/#installazione-del-bridgegateway-zigbee","title":"Installazione del BRIDGE/Gateway ZigBee","text":"<p>ZigBee, uno degli standard pi\u00f9 adottati in domotica personale.</p> <p>Per poter gestire i dispositivi ZigBee occorre dotarsi di BRIDGE/Gateway che sono in grado di tradurre le letture ed i comandi ZigBee su un protocollo su base Ethernet.</p> <p>I vari produttori forniscono BRIDGE/Gateway che per\u00f2 sono limitati alla propria linea di prodotti. Quindi se si desidera utilizzare apparecchiature di differenti produttori ci si trova a dover installare gateway per ogni singolo produttore.</p> <p>Nel mio caso, ad esempio, ho in utilizzo componenti Xiami/Aqara (di cui possiedo anche un BRIDGE), ed ho anche dispositivi ZigBee prodotti da IKEA.</p> <p>Per non dovermi dotare di singoli BRIDGE delle varie marche, opto per la creazione di un Gateway/BRIDGE proprietario che \u00e8 in grado di interfacciarsi con dispositivi ZigBee delle svariate marche.</p> <p>Tra le varie alternative, \u00e8 il caso di deCONZ, oggetto della presente guida, componente software che consente per l\u2019appunto di dotarsi gratuitamente di un BRIDGE/Gateway evoluto per la gestione della propria rete ZigBee: una volta installato, tale BRIDGE/Gateway espone delle API per instradare i messaggi da e per i componenti ZigBee tramite esso gestiti.</p>"},{"location":"homeassistant/#zigbee-coordinator-antenna","title":"ZigBee Coordinator (antenna)","text":"<p>Per far funzionare il BRIDGE/Gateway occorre anche dotarsi di un dispositivo ZigBee Coordinator (antenna). Io ho optato per un dispositivo USB molto consigliato dalla comunit\u00e0 : ConBee II</p> <p>Per quanto riguarda l'installazione di deCONZ ho optato per l'installazione in un container docker.</p> <p>N.B. Si consiglia, di utilizzare delle mini prolunghe USB per collegare sulla porta USB del Raspberry Pi l'antenna ConBee. Questo per evitare pi\u00f9 che accertate interferenze.</p>"},{"location":"homeassistant/#aggiunta-di-ulteriori-porte-seriali","title":"Aggiunta di ulteriori porte seriali","text":"<p>Dato che il Raspberry dispone di due porte seriali, ma una \u00e8 disabilitata di default, installando l'antenna potrebbe smettere di funzionare il modulo Bluetooth o non essere riconosciuta l'antenna stessa. Per evitare ci\u00f2 occorre effettuare una modifica al file <code>config.txt</code> presente nella root della scheda Micro SD.</p> <pre><code>sudo nano /boot/config.txt\n</code></pre> <p>La modifica da fare prevede l\u2019aggiunta, in fondo al file, del seguente codice (avere cura di aggiungere una riga vuota dopo le due righe di codice):</p> <pre><code>enable_uart=1\ndtoverlay=pi3-disable-bt\n</code></pre> <p>uscire e salvare (<code>Ctrl-X</code>, <code>Y</code>, <code>invio</code>), e infine spegnere il Raspberry Pi con:</p> <pre><code>sudo shutdown now\n</code></pre> <p>Completato lo shutdown, spegnere fisicamente l'unit\u00e0 per poi riaccenderla subito dopo.</p>"},{"location":"homeassistant/#installazione-del-modulo-conbee-ii","title":"Installazione del modulo ConBee II","text":"<p>Dopo aver inserito il modulo d'antenna su di una porta USB ed avvere riavviato il Raspberry Pi occorre effettuare una verifica per appurare che la porta logica sia stata assegnata all'antenna dal sistema operativo.</p> <p>Per fare questo prepariamo un semplice script per elencare le interfacce hardware in uso.</p> <p>Collegandosi al Raspberry tramite SSH creare lo script:</p> <pre><code>sudo nano ports.sh\n</code></pre> <p>e copiare all'interno dell'editor il seguente codice:</p> <pre><code>#!/bin/bash\n\nfor sysdevpath in $(find /sys/bus/usb/devices/usb*/ -name dev); do\n    (\n        syspath=\"${sysdevpath%/dev}\"\n        devname=\"$(udevadm info -q name -p $syspath)\"\n        [[ \"$devname\" == \"bus/\"* ]]\n        eval \"$(udevadm info -q property --export -p $syspath)\"\n        [[ -z \"$ID_SERIAL\" ]]\n        echo \"/dev/$devname - $ID_SERIAL\"\n    )\ndone\n</code></pre> <p>uscire e salvare (<code>Ctrl-X</code>, <code>Y</code>, <code>invio</code>). Eseguire poi i comandi:</p> <pre><code>sudo chmod 777 ports.sh\n./ports.sh\n</code></pre> <p>A questo punto lo script \u00e8 eseguito ottenendo un output simile al seguente:</p> <pre><code>/dev/bus/usb/001/001 - Linux_6.1.21-v8+_dwc_otg_hcd_DWC_OTG_Controller_3f980000.usb\n/dev/bus/usb/001/003 - 0424_ec00\n/dev/bus/usb/001/002 - 0424_9514\n/dev/ttyACM0 - dresden_elektronik_ingenieurtechnik_GmbH_ConBee_II_DE2685810\n/dev/bus/usb/001/005 - dresden_elektronik_ingenieurtechnik_GmbH_ConBee_II_DE2685810\n</code></pre> <p>Questo elenco riporta tutte le interfacce allocate. La prima parte \u00e8 l\u2019allocazione logica assegnata dal sistema operativo (eg. /dev/bus/usb/001/001) mentre la seconda l\u2019etichetta descrittiva del device.</p> <p>Ovviamente bisogner\u00e0 autonomamente capire quale sia quella che ci interessa utilizzare.</p> <p>N.B. Nell\u2019esempio di cui sopra si nota una duplicazione della voce \u201cdresden_elektronik_ingenieurtechnik_GmbH_ConBee_II_DE2685810\u201c. Questo perch\u00e9 viene elencato sia l\u2019indirizzo della porta al quale \u00e8 fisicamente connesso il device USB (/dev/bus/usb/001/005) sia l\u2019indirizzo alias logico (/dev/ttyACM0). Si consiglia di utilizzare sempre quest\u2019ultimo tipo di indirizzamento piuttosto che il primo, e il motivo \u00e8 semplice: in caso di cambio di porta, l\u2019alias logico non cambia mai, evitando quindi problemi di configurazione sui software che utilizzino i device in questione.</p>"},{"location":"homeassistant/#instanziare-deconz","title":"Instanziare deCONZ","text":"<p>Prerequisito principale \u00e8 avere installato <code>docker</code> sul Raspberry Pi.</p> <p>Si sceglie di utilizzare <code>docker compose</code> in tal modo tutta la configurazione viene registrata all'interno del file <code>docker-compose.yaml</code> assieme agli altri container definiti (ad esempio il container di Home Asssistant).</p> <p>Al file <code>docker-compose.yaml</code> aggiungere la seguente configurazione (sotto il blocco services):</p> <pre><code>deconz:\n    container_name: deconz\n    image: deconzcommunity/deconz\n    volumes:\n    - \"/opt/deconz:/root/.local/share/dresden-elektronik/deCONZ\"\n    devices:\n    - \"/dev/ttyXXX\"\n    environment:\n    - \"TZ=Europe/Rome\"\n    - \"DECONZ_WEB_PORT=40850\"\n    - \"DECONZ_VNC_MODE=1\"\n    - \"DECONZ_VNC_PORT=40851\"\n    - \"DECONZ_VNC_PASSWORD=mia_password\"\n    network_mode: host\n    restart: always\n</code></pre> <p>dove ovviamente nel campo <code>devices</code> occorre indicare la porta precedentemente identificata (nell'esempio precedente <code>ttyACM0</code>)</p> <p>Una volta salvato il file eseguire il comando:</p> <pre><code>docker compose up -d deconz\n</code></pre> <p>Lanciato il comando, attendere il completamente del primo avvio. Ci potrebbe volere un po\u2019: per leggere in tempo reale i log e verificare quindi cosa stia succedendo all\u2019interno del container, eseguire il comando:</p> <pre><code>docker container logs deconz -f\n</code></pre> <p>in fondo al log dovremmo trovare qualcosa come:</p> <pre><code>[deconzcommunity/deconz] Starting deCONZ...\n[deconzcommunity/deconz] Current deCONZ version: x.xx.xx\n[deconzcommunity/deconz] Web UI port: 40850\n[deconzcommunity/deconz] Websockets port: 443\n[deconzcommunity/deconz] VNC port: 40851\n</code></pre> <p>Congratulazioni: deCONZ \u00e8 ora operativo.</p>"},{"location":"m5stack/","title":"M5Stack Core","text":"<p>[documento editato il 2022-05-01]</p> <p>M5Stack (https://m5stack.com) progetta e produce kit di sviluppo open-source, incluso hardware, piattaforma di programmazione e soluzioni IoT.</p> <p>In particolare questo documento si riferisce all'utilizzo della piattaforma M5Stack Core, che consiste in una famiglia di controllori basati su microcontrollori ESP32 e caratterizzata dalla costruzione modulare \"stackabile\".</p> <p>Le istruzioni che seguono sono testate personalmente sul modello M5Stack Core FIRE.</p>"},{"location":"m5stack/#arduino-ide-environment-su-macbook-pro-m1-pro","title":"Arduino IDE environment (su MacBook Pro M1 Pro)","text":"<p>Ovviamente se riporto questi appunti significa che la guida ufficiale necessita di alcune personalizzazioni affinch\u00e8 si riesca a far funzionare il tutto.</p> <p>Partiamo dalla guida ufficiale: Arduino IDE environment - M5Core, e seguiamo i seguenti passaggi:</p> <ol> <li> <p>Istallazione del driver USB, selezionando <code>CP210x_VCP_MacOS</code>, l'altro driver nel mio caso non \u00e8 stato necessario</p> </li> <li> <p>Scaricare l'IDE Arduino: pur volendo utilizzare la nuova versione 2.0 \u00e8 necessario    installare anche la versione precedente in quanto solo    su questa sembra funzionare l'installazione dei dispositivi e delle librerie necessarie.    Quindi scaricare sia la versione <code>Arduino IDE 1.8.x</code> che la versione <code>Arduino IDE 2.0 RC</code> dal sito ufficiale.</p> </li> <li> <p>Installare entrambe le versioni di Arduino IDE, io personalmente le ho installate nella    cartella <code>~/Applications</code> dell'utente e non nella cartella globale.</p> </li> <li> <p>Eseguire la versione 1.8.x e, seguendo le istruzioni copiare tra gli URL per la gestione di schede addizionali:</p> </li> </ol> <p><code>txt    https://m5stack.oss-cn-shenzhen.aliyuncs.com/resource/arduino/package_m5stack_index.json</code></p> <p></p> <ol> <li> <p>E' ora possibile installare le schede M5Stack nella configurazione del Gestore schede </p> </li> <li> <p>Installazione delle librerie</p> <p>Attenzione</p> <p>Installando le librerie nella guida ufficiale si richiede di installare tutte le librerie dipendenti, ma purtroppo buona parte di esse sembrano avere problemi di installazione, almeno sul mio MacBook Pro M1 Pro    Da Gestione librerie installare le seguenti librerie (versioni installate al momento della scrittura della presente guida):</p> </li> <li>M5Stack (0.4.0)</li> <li> <p>M5GFX (0.0.20)</p> </li> <li> <p>Preparare sketch di test :</p> </li> </ol> <p>```c    #include  <p>/ After M5Core is started or reset    the program in the setUp () function will be run, and this part will only be run once.    After M5Core is started or reset, it will start to execute the program in the setup() function, and this part will only be executed once. /    void setup(){      M5.begin(); //Init M5Core. Initialize M5Core      M5.Power.begin(); //Init Power module. Initialize the power module                        / Power chip connected to gpio21, gpio22, I2C device                          Set battery charging voltage and current                          If used battery, please call this function in your project /      M5.Lcd.print(\"Hello World\"); // Print text on the screen (string) Print text on the screen (string)    }</p> <p>/ After the program in setup() runs, it runs the program in loop()    The loop() function is an infinite loop in which the program runs repeatedly    After the program in the setup() function is executed, the program in the loop() function will be executed    The loop() function is an endless loop, in which the program will continue to run repeatedly /    void loop() {</p> <p>}    ```</p> <ol> <li>Programmare il dispositivo, usando Arduino IDE 2.0.0:</li> <li>collegare la scheda alla porta USB</li> <li>selezionare la scheda : M5Stack-FIRE</li> <li>selezionare la porta di comunicazione : /dev/cu.usbserial-02161434 (o similare)</li> <li>selezionare la voce di men\u00f9 <code>Sketch/Carica</code></li> </ol> <p>Errore di compilazione su Arduino IDE 1.8.x</p> <p>In fase di compilazione la IDE cerca di utilizzare il comando <code>python</code> per eseguire la compilazione, ma purtroppo questo comando non \u00e8 pi\u00f9 presente in MacOS, occorre utilizzare il comando <code>python3</code>.</p> <p>Una possibile soluzione \u00e8 quella di creare un link di <code>python3</code> come <code>python</code>:</p> <p><code>sudo ln -s -f /usr/bin/python3 /usr/local/bin/python</code></p> <p>e lanciare poi l'IDE da linea di comando:</p> <p><code>./Applications/Arduino.app/Contents/MacOS/Arduino</code> </p>"},{"location":"ocifreetier/","title":"Oracle Cloud Interface Free Tier","text":"<p>[documento editato il 2025-05-06]</p> <p>Il Free Tier di Oracle Cloud Infrastructure (OCI) \u00e8 un\u2019offerta che consente agli utenti di utilizzare alcuni servizi cloud di Oracle gratuitamente, senza limiti di tempo su alcune risorse (denominate Always Free) e con accesso temporaneo ad altri servizi pi\u00f9 avanzati (detti Free Trial o Trial Credit).</p> <p>Ovviamente qui ci limitiamo ad utilizzare alcuni dei servizi definiti Always Free.</p> <p>I servizi Always Free sono:</p> <ul> <li>\u2601\ufe0f Compute</li> <li>2 istanze AMD o Intel (VM.Standard.E2.1.Micro) con:<ul> <li>1 vCPU e 1 GB RAM ciascuna</li> <li>Ideale per piccole applicazioni web, bot, test ecc.</li> </ul> </li> <li> <p>4 OCPU + 24 GB RAM su Arm-based instances (Ampere A1)[^1]</p> <ul> <li>Puoi usarli come una sola VM o fino a 4 VM pi\u00f9 piccole.</li> <li>Prestazioni molto buone per il free tier.</li> </ul> </li> <li> <p>\ud83d\udcbe Block Volume (Storage)</p> </li> <li>2 volumi fino a 200 GB totali.</li> <li> <p>Pu\u00f2 essere usato come disco di sistema o aggiuntivo alle istanze compute.</p> </li> <li> <p>\ud83d\udce6 Object Storage</p> </li> <li>10 GB di standard storage</li> <li>10.000 richieste PUT e 1.000.000 richieste GET al mese</li> <li> <p>Perfetto per salvare file, backup, log, etc.</p> </li> <li> <p>\ud83d\udee2\ufe0f Autonomous Database (ATP/ADW)</p> </li> <li>2 database (ATP = Autonomous Transaction Processing, ADW = Autonomous Data Warehouse)</li> <li> <p>Ognuno con:</p> <ul> <li>1 OCPU</li> <li>20 GB di storage</li> <li>Console SQL Web inclusa</li> </ul> </li> <li> <p>\ud83c\udf10 Networking</p> </li> <li>10 TB al mese di traffico in uscita (verso internet)</li> <li>IP pubblico statico gratuito per le istanze compute</li> <li> <p>VCN, subnet, firewall, route table, DNS</p> </li> <li> <p>\ud83d\udce1 Load Balancer</p> </li> <li>1 load balancer gratuito:</li> <li> <p>10 Mbps di bandwidth</p> </li> <li> <p>\ud83d\udcca Monitoring &amp; Logging</p> </li> <li>Metriche e log base inclusi (con limiti), utili per il monitoraggio delle risorse.</li> </ul> <p>\u26a0\ufe0f Limitazioni importanti</p> <ul> <li>Le risorse Always Free hanno limiti rigidi (es. 1 GB RAM, 10 GB Object Storage, ecc.)</li> <li>Le risorse gratuite vengono disattivate se non usate per troppo tempo.</li> <li>Per l\u2019attivazione serve una carta di credito, ma Oracle non addebita nulla senza consenso. </li> </ul> <p>Nonostante queste limitazioni, OCI Free Tier \u00e8 utilizzabile senza la preoccupazione di costi nascosti in quanto risulta possibile attivare soltanto le funzionalit\u00e0 gratuite, mentre per utilizzare funzionalit\u00e0 a costo occorre esplicitamente cambiare il proprio account ad un abbonamento a pagamento.</p> <p>Ecco alcuni esempi di utilizzo del Free Tier:</p> <ul> <li>Ospitare un sito o un\u2019app web su una VM Ampere</li> <li>Creare un piccolo database autonomo per sviluppo</li> <li>Salvare file e backup su Object Storage</li> <li>Usare un load balancer per una demo o test</li> <li>Avviare container Docker su VM gratuite</li> </ul>"},{"location":"ocifreetier/#creiamo-una-istanza-ampere-a1-arm-based-4-ocpu-e-24gb","title":"Creiamo una istanza Ampere A1 (Arm-based) 4 OCPU e 24GB","text":"<p>I prerequisiti sono:</p> <ul> <li>Aver creato un account su https://oracle.com/cloud/free</li> <li>Aver completato la verifica della carta ed essere nel periodo di trial o nella modalit\u00e0 Always Free</li> <li>Aver accettato il contratto per le istanze Arm (lo chiede al primo avvio)</li> </ul> <p>Quando creiamo un account OCI di prova gratuito, per impostazione predefinita verranno creati un tenant, un compartimento radice, una rete cloud virtuale (VCN) e un gateway internet.</p>"},{"location":"ocifreetier/#1-creare-una-nuova-instanza-di-calcolo","title":"1. Creare una nuova instanza di calcolo","text":"<p>Eleguire il login a OCI Console Selezionare dal men\u00f9 hamburger [\u2261] selezionare <code>Compute</code> \u2192 <code>Instances</code></p> <p>Nella pagina Instances</p> <ol> <li>selezionare il Compartment <code>(root)</code></li> <li>Fare click su <code>Create instance</code></li> </ol> <p></p>"},{"location":"ocifreetier/#2-configurare-i-parametri-dellistanza","title":"2. Configurare i parametri dell'istanza","text":"<p>Nella pagina Create compute instance compilare i campi come segue.</p> <ul> <li>Name : scegli un nome (es. ampere-server)</li> <li>Create in compartment: lasciare quello di default (root)</li> </ul> <p>Scegli Image e Shape selezionando l'apposita <code>Edit</code></p> <p><code>Change image</code> permette di scegliere l'immagine del sistema operativo tra quelli proposti Always Free-eligible (Oracle Linux, Ubuntu, CentOS).</p> <p>Per esempio utilizziamo quello proposto di default: Oracle Linux 8</p> <p><code>Change shape</code> permette di scegliere tra alcune architetture Always Free-eligible :</p> <ul> <li>VM.Standard.E2.1.Micro : AMD 2.0 GHz, 1 GB RAM</li> <li>VM.Standard.A1.Flex: Ampere (ARM) 3.0 GHZ : fino a 24 GB RAM</li> </ul> <p>Scegliamo Ampere, 4 OCPU e 24 GB RAM</p> <p>Occorre aggiungere una chiave SSH per la connessione remota alla macchina, nella sezione Add SSH keys \u00e8 possibile caricare una propria chiave pubblica oppure permette di creare una nuova dedicata.</p> <p>Nella sezione Boot volume selezionare <code>Specify a custom boot volume size</code> e nel campo che compare scegliere la dimensione. Il minimo \u00e8 49GB, ma avendo a disposizione fino a 200GB si sceglie di dedicarne 100GB per questa VM. Lasciare il parametro VPU con il valore di default.</p> <p>Terminare la creazione della VM premendo sul comando <code>Create</code> a fondo pagina.</p> <p>[^1] Oracle ha cominciato a ridurre drasticamente le possibilit\u00e0 di installare gratuitamente      l'istanza Ampere 1 (Arm Based). Questo dipende molto dalla regione scelta in fase di      registrazione: ad esempio in Switzerland North (Zurich) non sono pi\u00f9 disponibili      istanze gratuite.</p>"},{"location":"pihole/","title":"Pi-hole","text":"<p>[documento editato il 2025-03-16]</p>"},{"location":"pihole/#pi-hole-il-dns-fatto-in-casa-per-proteggerci","title":"Pi-hole: il DNS fatto in casa per proteggerci","text":"<p>Pi-hole \u00e8 una soluzione open source che funge da server DNS locale con capacit\u00e0 di filtraggio, progettato principalmente per bloccare pubblicit\u00e0 e malware su reti domestiche o aziendali. Opera come un \"filtro\" tra gli utenti della rete e il mondo internet, intercettando le richieste DNS e confrontandole con liste nere di domini noti per contenere pubblicit\u00e0 invasiva, spyware, ransomware, malware, cryptoware, cryptominer e altri tipi di contenuti indesiderati. Installato su un dispositivo dedicato (come Raspberry Pi), pu\u00f2 proteggere tutti i dispositivi connessi alla rete, bloccando automaticamente le richieste a domini dannosi o pubblicitari senza necessit\u00e0 di configurazione su ciascun dispositivo.</p>"},{"location":"pihole/#configurazione-e-personalizzazione-di-pi-hole","title":"Configurazione e personalizzazione di Pi-hole","text":"<p>Per configurare Pi-hole, \u00e8 necessario installarlo su un dispositivo che funger\u00e0 da server DNS, come Raspberry Pi, utilizzando guide specifiche disponibili sul sito ufficiale di Pi-hole. Una volta installato, l'utente pu\u00f2 accedere all\u2019interfaccia web di Pi-hole per personalizzare le impostazioni, inclusa la gestione delle liste nere e whitelist, il monitoraggio del traffico DNS e le statistiche sulla rete.</p> <p>Nel nostro caso verr\u00e0 installato come container LXC in proxmox. E' installato utilizzando il seguente script: https://pimox-scripts.com/scripts?id=pihole Conviene avere l'accortezza di installarlo con IP Statico (nel mio caso 192.168.1.1) per facilitarne la configurazione.</p> <p>Si pu\u00f2 accedere all'interfaccia di configurazione puntando all'indirizzo : http://192.168.1.1/admin</p> <p>Impostazione della password</p> <p>Occorre creare la password di accesso prima di poter accedere la prima volta:</p> <p>da Proxmox accedere alla Shell del container appena creato. Eseguire il comando : <code>pihole -a -p</code> e creare la password </p>"},{"location":"pihole/#pi-hole-come-dns-su-tutti-i-dispositivi","title":"Pi-hole come DNS su tutti i dispositivi","text":"<p>Affinch\u00e9 il tutto sia funzionante occorre impostare in tutti i dispositivi l'indirizzo di Pi-Hole come server DNS. Siccome questa operazione potrebbe essere lunga e, per alcuni dispositivi, potrebbe non essere facilmente fattibile si sceglie la soluzione di attivare il servizio DHCP in Pi-hole, cos\u00ec sar\u00e0 questo servizio a programmare i dispositivi con tutti gli indirizzi necessari.</p> <ol> <li>disabilitare il servizio DHCP dal router o da eventuale altro server</li> <li>Dal men\u00f9 <code>Settings/DHCP</code> abilitare DHCP server enabled</li> <li>Range of IP adresses to hand out : From: <code>192.168.1.50</code> To: <code>192.168.1.199</code></li> <li>Router(gateway) IP address : Router: <code>192.168.1.254</code></li> </ol>"},{"location":"pihole/#alcuni-link-di-riferimento","title":"Alcuni link di riferimento","text":"<ul> <li>https://www.navigaresenzapubblicita.org</li> <li>Guida all'installazione</li> <li>Configurazione e personalizzazione</li> </ul>"},{"location":"proxmoxonoci/","title":"Installa Proxmox VE 8 su Oracle OCI (free tier)","text":"<p>[documento editato il 2025-05-06]</p> <p>Oracle nella piattaforma Oracle Cloud Infrastructure (OCI) mette a dispisizione un ottimo tier gratuito In questo tier sono disponibili risorse per creare instanze di macchine virtuali nel piano che viene indicato come always-free.</p> <p>In particolare si hanno a disposizione:</p> <ul> <li>due instanze AMD x86_64 con 1/8 OCPU (corrispondenti a 2 vCPU) e 1GB di RAM.</li> <li>una istanza ARM-based 4 core e 24 GB di RAM</li> </ul> <p>Inoltre si hanno a disposizione 200GB di blocco dati da utilizzare come memoria di massa. Siccome il minimo utilizzabile per ogni istanza \u00e8 pari a 49GB, alla fine si consiglia di utilizzare:</p> <ul> <li>100GB per la istanza ARM-Based</li> <li>50GB per ogni istanza AMD</li> </ul> <p>Fatta questa premessa \u00e8 chiaro che se si intende utilizzare una istanza OCI per far girare un server Proxmox VE allora l'unica possibilit\u00e0 \u00e8 quella di utilizza l'istanza ARM-based che presenta una buona quantit\u00e0 di memoria RAM, risorsa indispensabile per il sistema Proxmox VE.</p> <p>Essendo questa una macchina con architettura ARM buona parte della configurazione sar\u00e0 simile a quanto gi\u00e0 rappresentato nel documento: Installa Proxmox 8 su Raspberry Pi 5.</p> <p>La vera difficolt\u00e0 \u00e8 quella di riuscire ad installare l'immagine di Proxmox VE sull'istanza OCI, inquanto \u00e8 una immagine non prevista dal sistema automatizzato messo a disposizione da Oracle.</p> <p>Reference</p> <p>Buona parte delle procedure di seguito elencate sono state descritte sul Frank Ruan's Blog ed in particolare nell'articolo: Installing Proxmox VE on OCI</p>"},{"location":"proxmoxonoci/#debian-su-istanza-vmstandarda1flex","title":"Debian su istanza VM.Standard.A1.Flex","text":"<p>Si da qui per scontato che sia stata creata una instanza selezionando l'architettura ARM-based e collegando un blocco dati di 100GB.</p> <p>Occorre segnarsi l'indirizzo IP pubblico dell'istanza ed avere accesso alla console di controllo. Inoltre occorre avere l'accesso ssh remoto, normalmente viene utilizzato una chiave pubblica fornita in fase di creazione dell'istanza.</p> <p>Ora occorre assicurarsi di avere settato il firewall per permettere al traffico internet di raggiungere l'istanza.</p> <p>Connettersi all'istanza tramite connessioe SSH ed scaricare l'immagine necessaria per installare il da rete Proxmox:</p> <pre><code>sudo -i\ncd /boot/efi\nwget https://boot.netboot.xyz/ipxe/netboot.xyz-arm64.efi\n</code></pre> <p>Una volta eseguito il download sconnettersi dalla macchina. Ora dovremo far ripartire la macchina cercando di intercettare al boot in modo da utilizzare l'immagine appena scaricata.</p> <p>Nella pagina di interfaccia di OCI assicurarsi di avere lanciato la Console collegata all'istanza. Per fare questo, una volta selezionata l'istanza, scegliere la voce Console connection presente nel men\u00f9 laterale.</p> <p>La qui utilizzare \"Lauch Cloud Shell connection\". Questo apre a fondo pagina una console (Cloud Shell) connessa all'istanza.</p> <p>Seguire attendamente le seguenti operazioni:</p> <ol> <li> <p>dalla pagina detaggli operare sul comando Reboot e scegliere l'opzione 'Force reboot the instance by immediately powering off, then powering back on'</p> </li> <li> <p>Fare attenzione a ci\u00f2 che avviene nella console (Cloud Shell) e premere <code>ESC</code> quando inizia il reboot per far apparire la configurazione del Bios. </p> </li> <li> <p>Utilizzando le frecce per muoversi selezionare: <code>Boot Maintenance Manager</code> -&gt; <code>Boot From File</code> -&gt; Scegli il file dall'hard disk <code>netboot.xyz-arm64.efi</code></p> </li> <li> <p>Se tutto \u00e8 andato come da copione si presenta l'interfaccia iPXE seguente </p> </li> <li> <p>Seleziona <code>Linux Network Installs</code> -&gt; <code>Debian</code> -&gt; <code>Debian 12.0 (bookworm)</code> -&gt; <code>Text Based Install</code></p> </li> <li> <p>procedere con l'istallazione facendo attenzione nel momento in cui chiede il partizionamento: scegliere 'Guided - use entire disk and set up LVM' </p> </li> <li> <p>A seguire accettare tutte le impostazioni di default</p> </li> <li> <p>Riavviare il sistema</p> </li> </ol>"},{"location":"proxmoxonoci/#configurazione-di-debian","title":"Configurazione di Debian","text":"<p>Una volta installato, il sistema ha la necessit\u00e0 di alcune configurazioni utili per essere facilmente utilizzato.</p> <ol> <li> <p>Connessione SSH con utente (non root) creato durante l'installazione utilizzando l'indirizzo pubblico della istanza.</p> </li> <li> <p>installare 'sudo' e vari altri software utili</p> </li> </ol> <p><code>shell    su -    Password: (inserire la password di root)    apt update    apt install sudo wget curl iftop vnstat neofetch vim nano net-tools    exit</code></p> <ol> <li>aggiungere l'utente standard ai 'sudoers'. Lavorando sempre come 'root' eseguire</li> </ol> <p><code>shell    su -    usermod -aG sudo [nome utente]    groups [nomeutente]    exit</code></p> <p>L'utente deve uscire e rientrare affinch\u00e8 venga caricata l'appartenenza al gruppo 'sudo'</p> <ol> <li>(Opzionale) abilitare sudo senza password</li> </ol> <p><code>shell    sudo visudo</code></p> <p>Editare il file aperto, cercare la linea con <code>%sudo ...</code> e modificarla in</p> <p><code>text    %sudo   ALL=(ALL:ALL) NOPASSWD:ALL</code></p> <p>Chiudere il file con <code>Ctrl+x</code>, <code>y</code>, <code>Invio</code></p> <ol> <li>(Opzionale) aggiungere chiave pubblica per connessione SSH senza necessita di inserimento password.</li> </ol> <p>Dal proprio computer eseguire il comando:</p> <p><code>shell    ssh-copy-id -i .ssh/[chiave]] [user]@[ip-address]</code></p> <p>Viene chiesta la password e al termine dovrebbe indicare di aver copiato una chiave</p>"},{"location":"proxmoxonoci/#configurazione-della-rete","title":"Configurazione della rete","text":"<p>Si andr\u00e0 a configurare la rete con IP statico.</p> <p>Segnarsi l'indirizzo IP della macchina virtuale letto tramite il comando <code>ip address</code></p> <p>Nel mio caso : <code>10.0.0.177</code></p>"},{"location":"proxmoxonoci/#impostazione-ip-statico","title":"Impostazione IP statico","text":"<p>Editare il file <code>/etc/network/interfaces</code></p> <p>Il file si presenta cos\u00ec:</p> <pre><code># This file describes the network interfaces available on your system\n# and how to activate them. For more information, see interfaces(5).\n\nsource /etc/network/interfaces.d/*\n\n# The loopback network interface\nauto lo\niface lo inet loopback\n\n# The primary network interface\nallow-hotplug enp0s3\niface enp0s3 inet dhcp\n</code></pre> <p>Occorre modificare la parte finale in :</p> <pre><code># The primary network interface\nallow-hotplug enp0s3\n# iface enp0s3 inet dhcp\n# Define Static IP\niface enp0s3 inet static\n   address 10.0.0.117\n   netmask 255.255.0.0\n   gateway 10.0.0.1\n</code></pre>"},{"location":"proxmoxonoci/#edit-file-etchosts","title":"Edit file /etc/hosts","text":"<p>Editare il file <code>/etc/hosts</code> che dovrebbe essere simile a:</p> <pre><code>127.0.0.1       localhost\n127.0.1.1      pve-oci.vcn01191127.oraclevcn.com       pve-oci\n\n# The following lines are desirable for IPv6 capable hosts\n::1     localhost ip6-localhost ip6-loopback\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\n</code></pre> <p>Modificarlo in (sostituire HOSTNAME con il proprio hostname, nel mio caso <code>pve-oci</code>):</p> <pre><code>127.0.0.1    localhost.localdomain  localhost\nPUBLIC_IP    HOSTNAME.proxmox.com   HOSTNAME\n\n# The following lines are desirable for IPv6 capable hosts\n::1     localhost ip6-localhost ip6-loopback\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\n</code></pre> <p>Riavviare l'istanza.</p>"},{"location":"proxmoxonoci/#installare-proxmox-ve-su-debian-bookworm","title":"Installare Proxmox VE su Debian bookworm","text":"<p>Reference</p> <p>Si fa riferimento alla guida ufficiale del porting di Proxmox su architettura arm64</p> <p>Install Proxmox VE on Debian bookworm</p>"},{"location":"proxmoxonoci/#aggiungere-il-repository-di-proxmox-ve","title":"Aggiungere il repository di Proxmox VE","text":"<p>Occorre eseguire i seguenti comandi come <code>root</code>, quindi invocare il comando <code>sudo su -</code></p> <p>Aggiungiamo mil repository</p> <pre><code>echo 'deb [arch=arm64] https://mirrors.apqa.cn/proxmox/debian/pve bookworm port'&gt;/etc/apt/sources.list.d/pveport.list\n</code></pre> <p>Aggiungiamo la chive del repository</p> <pre><code>curl -L https://mirrors.apqa.cn/proxmox/debian/pveport.gpg -o /etc/apt/trusted.gpg.d/pveport.gpg \n</code></pre> <p>Aggiorniamo il repository ed il sistema</p> <pre><code>apt update &amp;&amp; apt full-upgrade\n</code></pre>"},{"location":"proxmoxonoci/#installiamo-i-pacchetti-proxmox-ve","title":"Installiamo i pacchetti Proxmox VE","text":"<p>Aggiungiamo <code>ifupdown2</code></p> <pre><code>apt install ifupdown2\n</code></pre> <p>Ora \u00e8 il momento dei pacchetti Proxmox VE</p> <pre><code>apt install proxmox-ve postfix open-iscsi\n</code></pre> <p>Durante questa installazione vengono fatte alcune richieste. Scegliere 'Local only' alla richiesta \"Postfix Configuration\"</p> <p></p> <p>E Accettare il nome server proposto:</p> <p></p> <p>A termine installazione viene richiesto se mantenere le modifiche al file `/etc/apt/sources.list.d/pveport.list</p> <pre><code>Configuration file '/etc/apt/sources.list.d/pveport.list'\n ==&gt; File on system created by you or by a script.\n ==&gt; File also in package provided by package maintainer.\n   What would you like to do about it ?  Your options are:\n    Y or I  : install the package maintainer's version\n    N or O  : keep your currently-installed version\n      D     : show the differences between the versions\n      Z     : start a shell to examine the situation\n The default action is to keep your current version.\n*** pveport.list (Y/I/N/O/D/Z) [default=N] ?\n</code></pre> <p>Scegliere l'opzione di default <code>N</code></p>"},{"location":"proxmoxonoci/#accesso-alla-console-di-controllo-porta-8006","title":"Accesso alla console di controllo (porta 8006)","text":"<p>Ora il sistema \u00e8 installato, occorre solo riuscire ad accedere alla console di gestione pubblicata sulla porta 8006.</p> <p>Possiamo raggiungere questa porta in due modi:</p> <ul> <li>pubblicando la porta su internet (modo pi\u00f9 semplice ma nmeno sicuro)</li> <li>utilizzare una connessione VPN come ad esempio Tailscale.</li> </ul>"},{"location":"proxmoxonoci/#pubblicazione-della-porta","title":"Pubblicazione della porta","text":"<p>Controlla le regole del firewall su OCI</p> <p>Su Oracle Cloud Infrastructure, devi configurare correttamente le Security Lists o i Network Security Groups (NSG).</p> <ol> <li> <p>Vai su OCI Console -&gt; Networking -&gt; Virtual Cloud Network (VCN)</p> </li> <li> <p>Selezione la rete e dal nuovo men\u00f9 scegli la voce Security Lists poi seleziona la lista presente</p> </li> <li> <p>Aggiungi la nuova regola Add Ingress Rules con i seguenti parametri:</p> </li> <li>Source CIDR: Il tuo IP pubblico o 0.0.0.0/0 (se vuoi aprirlo a tutti)</li> <li>Destination Port Range: 8006</li> <li>Protocol: TCP</li> <li>Stateless: No</li> </ol> <p></p> <p>Ora \u00e8 possibile accedere alla console di Proxmox tramite l'indirizzo:</p> <p><code>https://IP_PUBBLICO:8006</code></p>"},{"location":"proxmoxonoci/#utilizzo-di-una-vpn-tailscale","title":"Utilizzo di una VPN (Tailscale)","text":"<p>Potrebbe essere utile configurare la macchina su di una propria VPN in modo che sia facilemnte accessibile dalla propria rete interna.</p> <p>Personalmente utilizzo Tailscale. Per eseguire l'installazione di Tailscale sulla macchina si esegue lo script per l'installazione su piattaforma Linux; da console lanciare il comando:</p> <pre><code>curl -fsSL https://tailscale.com/install.sh | sh\n</code></pre> <p>Terminata l'installazione proseguire con la registrazione della macchina sulla propria VPN:</p> <pre><code>sudo tailscale up\n</code></pre> <p>e seguire il link fornito per terminare la registrazione.</p> <p>ATTENZIONE</p> <p>Una volta registrata la macchina si consiglia di disabilitare la scadenza della chiave di connessione agendo sul menu <code>...</code> e attivando la voce <code>Disable key expiry</code></p>"},{"location":"proxmoxonoci/#configurazione-personalizzata-per-oracle-cloud","title":"Configurazione personalizzata per Oracle Cloud","text":"<p>Si consiglia di seguire le impostazioni consigliate da Tailscale per la gestione corretta su Cloud Oracle presenti qui</p>"},{"location":"proxmoxonoci/#1-autorizza-porta-udp-41641","title":"1. Autorizza porta UDP 41641","text":"<p>Agendo sulla pagina di configurazione di Oracle Cloud selezionere il tab Network e selezionare Virtual Cloud Networks e poi selezionare la rete VCN utilizzata dalla macchina virtuale</p> <p></p> <p>Selezionare il tab Security e poi selezionare la lista di sicurezza (probabilmente l'unica di Default)</p> <p></p> <p>Scegliere secutity Rules A questo punto aggiungere una _Regola ingresso Stateless per 0.0.0.0/0 UDP porta 41641</p> <p></p>"},{"location":"proxmoxonoci/#2-pubblica-tutta-la-sottorete-vcn-tramite-tailscale","title":"2. Pubblica tutta la sottorete VCN tramite Tailscale","text":"<p>Pu\u00f2 essere utile permettere alla connessione Tailscale di avere accesso a tutta la sottorete delle proprie VM su Oracle.</p> <p>Da console eseguire il seguente comando</p> <pre><code>sudo tailscale up --advertise-routes=10.0.0.0/16,169.254.169.254/32 --accept-dns=false\n</code></pre> <p>NOTA</p> <p>Affinch\u00e9 la sottorete sia pubblicata effettivamente, occorre agire sulla \"Admin Console\" di Tailscale e selezionando il device autorizzare la sottorete.</p>"},{"location":"proxmoxonoci/#3-aggiungere-oracle-dns-alla-tailnet","title":"3. Aggiungere Oracle DNS alla tailnet","text":"<p>Nella console di amministrazione nella sezione DNS di tailscale</p> <p>Selezionare <code>Add nameserver</code>/<code>Custom...</code></p> <p>Configurare come da immagine seguente</p> <p></p>"},{"location":"proxmoxonoci/#accesso-alla-console-e-prima-configurazione","title":"Accesso alla console e prima configurazione","text":"<p>Una volta che si accede alla console occorre eseguire alcune prime operazioni:</p>"},{"location":"proxmoxonoci/#aggiunta-del-repository-di-proxmox","title":"Aggiunta del repository di Proxmox","text":"<ol> <li> <p>Accedi tramite utente <code>root</code> creato durante l'installazione di Debian</p> </li> <li> <p>Seleziona la voce <code>Repositories</code>.</p> </li> <li> <p>Seleziona il comando <code>Add</code></p> </li> <li> <p>Dal popup scegli come Repository <code>No-Subscription</code></p> </li> </ol>"},{"location":"proxmoxonoci/#creare-un-cluster-proxmox-tra-due-nodi-connessi-tramite-tailscale","title":"Creare un cluster Proxmox tra due nodi connessi tramite tailscale","text":"<p>NOTA: Questa procedura presuppone l'uso di Proxmox 8.</p> <p>I due nodi in questione saranno qui indicati con <code>pve1</code> e <code>pve2</code>. Occorre accertarsi che comunque non abbiano lo stesso nome.</p>"},{"location":"proxmoxonoci/#1-imposta-correttamente-etchosts-su-entrambi-i-nodi","title":"1. Imposta correttamente /etc/hosts su entrambi i nodi","text":"<p>In entrambi i nodi editare il file <code>/etc/hosts</code> aggiungendo le seguenti righe:</p> <pre><code>100.x.y.z   pve1\n100.a.b.c   pve2\n</code></pre> <p>Usare gli IP Tailscale reali al posto di 100.x.y.z e 100.a.b.c</p>"},{"location":"proxmoxonoci/#2-creare-il-cluster-sul-nodo-principale-pve1","title":"2. Creare il cluster sul nodo principale (pve1)","text":"<pre><code>pvecm create nome-cluster\n</code></pre> <p>Importante: A questo punto Proxmox user\u00e0 la prima interfaccia di rete disponibile. Per forzare l\u2019uso di Tailscale, modificheremo i file di configurazione subito dopo.</p>"},{"location":"proxmoxonoci/#3-modificare-la-configurazione-del-cluster","title":"3. Modificare la configurazione del cluster","text":"<p>Su <code>pve1</code>, editare il file <code>/etc/pve/corosync.conf</code> e modificare la sezione <code>interface</code>:</p> <pre><code>nodelist{\n   node{\n      name: pve1\n      nodeid: 1\n      quorum_votes: 1\n      ring0_addr: 100.x.y.z\n  }\n}\n</code></pre> <p>Inoltre occorre modificare la geestione del \"quorum\" per permettere l'uso di solo 2 nodi.</p> <p>Modificare la sezione <code>totem</code> aggiungendo:</p> <pre><code>two_node: 1\nwait_for_all: 0\n</code></pre> <p>Poi riavviare il servizio <code>corosync</code></p> <pre><code>systemctl restart corosync\n</code></pre>"},{"location":"proxmoxonoci/#4-aggiungere-il-secondo-nodo-pve2","title":"4. Aggiungere il secondo nodo (pve2)","text":"<p>Sul nodo pve2 eseguire:</p> <pre><code>pvecm add pve1\n</code></pre> <p>Usare l'hostname di <code>pve1</code> per assicurarsi che il cluster venga contattato tramite Tailscale e che la verifica dell'hostname sia accettata</p> <p>Il risultato dovrebbe essere qualcosa come:</p> <pre><code>root@pve2:~# pvecm add pve1\nPlease enter superuser (root) password for 'pve1': ********\nEstablishing API connection with host 'pve1'\nThe authenticity of host 'pve1' can't be established.\nX509 SHA256 key fingerprint is 9A:6D:E9:9A:DA:49:26:57:2B:57:62:21:A0:53:34:E6:D2:DA:5B:2B:EF:7B:FA:24:8B:71:20:C9:28:B2:00:3C.\nAre you sure you want to continue connecting (yes/no)? yes\nLogin succeeded.\ncheck cluster join API version\nNo cluster network links passed explicitly, fallback to local node IP '100.x.y.z'\nRequest addition of this node\nJoin request OK, finishing setup locally\nstopping pve-cluster service\nbackup old database to '/var/lib/pve-cluster/backup/config-1744145363.sql.gz'\nwaiting for quorum...OK\n(re)generate node files\ngenerate new node certificate\nmerge authorized SSH keys\ngenerated new node certificate, restart pveproxy and pvedaemon services\nsuccessfully added node 'pve2' to cluster.\n</code></pre>"},{"location":"proxmoxonoci/#5-verificare-lo-stato-del-cluster","title":"5. Verificare lo stato del cluster","text":"<p>Su qualsiasi nodo eseguire:</p> <pre><code>pvecm status\n</code></pre>"},{"location":"proxmoxonpi5/","title":"Installa Proxmox 8 su Rasperry Pi 5","text":"<p>[documento editato il 2025-02-24]</p> <p>Normalmente Proxmox viene installato tramite immagine dedicata. Non essendo prevista ancora una immagine ufficiale dedicata al Rapberry Pi 5, si procede con l'installazione nativa su Raspberry OS.</p> <p>La procedura, in alcuni momenti, prevede l'accesso diretto alla scheda Pi 5. Si consiglia di utilizzare il sistema operativo Raspberry OS in versione lite (no desktop) ed installato su supporto SSD NVMe.</p> <p>Le procedure a seguire danno per scontato:</p> <ul> <li>sistema Raspberry OS 64bit lite</li> <li>utente con accesso a comando `sudo``</li> </ul> <p>Come documentazione di riferimento si consiglia il repository ufficiale: Proxmox-Port</p>"},{"location":"proxmoxonpi5/#preparazione-del-sistema","title":"Preparazione del sistema","text":"<p>Inanzi tutto \u00e8 buona norma effettuare un aggiornamento dei pacchetti</p> <pre><code>sudo apt update\nsudo apt upgrade\n</code></pre> <p>Occorre poi creare la password per l'utente root</p> <pre><code>$ sudo su\n$ passwd\nNuova password:\nReimmetere la nuova password:\npasswd: password aggiornata correttamente\n</code></pre>"},{"location":"proxmoxonpi5/#predisposizione-allinstallazione-di-proxmox","title":"Predisposizione all'installazione di Proxmox","text":"<p>Rimanendo loggati come root, scarichiamo le chiavi pubbliche dal repository del porting di Proxmox e le salviamo nel percorso di sistema <code>/usr/share/keyrings</code></p> <pre><code>curl -L https://mirrors.apqa.cn/proxmox/debian/pveport.gpg | tee /usr/share/keyrings/pveport.gpg\n</code></pre> <p>Non preoccuparsi se a terminale vengono visualizzati caratteri illeggibili. Al termine \u00e8 possibile ripulire il terminale con il comando <code>ctrl+L</code>. Eventuali caratteri rimasti non influiscono sul funzionamento.</p> <p>Successivamente inseriamo nella lista dei repository dei pacchetti debian anche quello del porting di Proxmox.</p> <pre><code>echo \"deb [deb=arm64 signed-by=/usr/share/keyrings/pveport.gpg] https://mirrors.apqa.cn/proxmox/debian/pve bookworm port\" | tee /etc/apt/sources.list.d/pveport.list\n</code></pre> <p>Ora che abbiamo aggiunto il repository, facciamo si che <code>apt</code> lo prenda in considerazione.</p> <pre><code>$ apt update\nTrovato:1 http://deb.debian.org/debian bookworm InRelease\nTrovato:2 http://deb.debian.org/debian-security bookworm-security InRelease\nTrovato:3 http://deb.debian.org/debian bookworm-updates InRelease\nTrovato:4 http://archive.raspberrypi.com/debian bookworm InRelease\nScaricamento di:5 https://mirrors.apqa.cn/proxmox/debian/pve bookworm InRelease [3.997 B]\nScaricamento di:6 https://mirrors.apqa.cn/proxmox/debian/pve bookworm/port arm64 Packages [566 kB]\nRecuperati 570 kB in 3s (179 kB/s)\nLettura elenco dei pacchetti... Fatto\nGenerazione albero delle dipendenze... Fatto\nLettura informazioni sullo stato... Fatto\nTutti i pacchetti sono aggiornati.\nW: Acquisizione del file \"port/binary-armhf/Packages\" saltata in quanto il repository \"https://mirrors.apqa.cn/proxmox/debian/pve bookworm InRelease\" non sembra fornire tale file (voce in sources.list errata?)\n</code></pre> <p>Non preoccuparsi del messaggio di warning.</p> <p>Ora occorre aggiornare la ditribuzione</p> <pre><code>apt dist-upgrade\n</code></pre> <p>Potrebbe aggiornare qualche pacchetto. Nel mio caso, avendo gi\u00e0 effettuato l'upgrade ad inizio procedura, non sono stati effettuati aggiornamenti.</p> <p>Prima della prossimo passo occorre segnarsi l'indirizzo IP del dispositivo</p> <pre><code>$ ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host noprefixroute\n       valid_lft forever preferred_lft forever\n2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n    link/ether 2c:cf:67:25:e3:50 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.1.180/24 brd 192.168.1.255 scope global dynamic noprefixroute eth0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::cb72:7680:a684:d070/64 scope link noprefixroute\n       valid_lft forever preferred_lft forever\n3: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n    link/ether 2c:cf:67:25:e3:51 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.1.181/24 brd 192.168.1.255 scope global dynamic noprefixroute wlan0\n       valid_lft 57673sec preferred_lft 57673sec\n    inet6 2001:b07:5d33:12c5:47ad:a67d:87aa:f672/64 scope global noprefixroute\n       valid_lft forever preferred_lft forever\n    inet6 fe80::4703:d3cd:4352:ca46/64 scope link noprefixroute\n       valid_lft forever preferred_lft forever\n</code></pre> <p>Nel mio caso sono attive due interfacce: <code>eth0</code> e <code>wlan0</code> rispettivamente agli indirizzi <code>192.168.1.180</code> e <code>192.168.1.181</code></p> <p>Ora occorre aggiornare il file <code>hosts</code> tramite comando <code>nano /etc/hosts</code> e modificarlo per renderlo simile a quanto segue:</p> <pre><code>127.0.0.1       localhost\n127.0.1.1       raspi5\n192.168.1.180   raspi5\n\n# The following lines are desirable for IPv6 capable hosts\n::1     localhost ip6-localhost ip6-loopback\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\n</code></pre> <p>In cui <code>raspi5</code> \u00e8 l'hostname del dispositivo.</p> <p>Ora si configurano le interfacce di rete per renderle utilizzabili da Proxmox. Utilizzare il comando <code>nano /etc/network/interfaces</code></p> <pre><code># interfaces(5) file used by ifup(8) and ifdown(8)\n# Include files from /etc/network/interfaces.d:\n#source /etc/network/interfaces.d/*\nauto lo\niface lo inet loopback\n\niface eth0 inet static\n\nauto vmbr0\niface vmbr0 inet static\n        address 192.168.1.180/24\n        gateway 192.168.1.254\n        bridge-ports eth0\n        bridge-stp off\n        bridge-fd 0\n</code></pre> <p>NOTA accertarsi che l'indirizzo del gateway sia quello corretto, altrimenti sar\u00e0 impossibile accedere ad internet.</p> <p>Ora installiamo le utility per i bridge di rete</p> <pre><code>apt install ifupdown2 bridge-utils\n</code></pre> <p>Se tutto \u00e8 andato a buon fine la rete \u00e8 stata riavviata (se si era connessi da remoto si \u00e8 persa la connessione).</p> <p>Per verificare che tutto funzioni provare ad effettuare un <code>ping www.google.com</code></p> <p>Come ultimo passo di predisposizione, importante affinch\u00e9 funzionino correttamente gli script per la compilazione di immagini docker, occorre utilizzare kernel con pagesize 4K.</p> <p>NOTA le linee seguenti fanno riferimento alla posizione dei file <code>/boot/firmware</code> relativa a Debian 12 Bullseye nel caso la propria installazione sia basata su _Debian 11 i file sono in <code>/boot</code> E' possibile verificare la propria distribuzione con il comando <code>cat /etc/os-release</code></p> <p>Per questo effettuare le seguenti modifiche: editare il file <code>config.txt</code> : <code>nano /boot/firmware/config.txt</code> ed aggiungere in calce al file la linea:</p> <pre><code>kernel=kernel8.img\n</code></pre> <p>Inoltre occorre modificare la linea di comando : <code>nano /boot/firmware/cmdline.txt</code></p> <p>inserendo i seguenti parametri alla fine della linea:</p> <pre><code>cgroup_enable=cpuset cgroup_enable=memory cgroup_memory=1\n</code></pre> <p>RIAVVIARE LA SCHEDA</p>"},{"location":"proxmoxonpi5/#installazione-di-proxmox","title":"Installazione di Proxmox","text":"<p>Effettuati tutti i preparativi possiamo finalmente installare Proxmox VE.</p> <pre><code>apt install pve-edk2-firmware\n</code></pre> <pre><code>apt install proxmox-ve postfix open-iscsi pve-edk2-firmware-aarch64\n</code></pre> <p>Durante l'installazione verranno richieste alcune informazioni, di seguito le risposte che ho selezionato:</p> Richiesta Scelta effettuata Postfix Configuration Nessuna Configurazione File di configurazione pveport.list N : mantiene la versione attualmente installata <p>Ora occorre riavviare ed il server Proxmox dovrebbe partire automaticamente.</p> <pre><code>reboot\n</code></pre>"},{"location":"proxmoxonpi5/#configurazione-di-proxmox-ve-8","title":"Configurazione di Proxmox VE 8","text":"<p>Accedere all'interfaccia web all'indirizzo : https://192.168.1.180:8006 oppure https://raspi5.local:8006</p>"},{"location":"proxmoxonpi5/#-todos-argomenti-da-aggiungere-ed-espandere","title":"-- TODOs - argomenti da aggiungere ed espandere","text":""},{"location":"proxmoxonpi5/#a-allargare-la-dimensione-dello-swap-file","title":"A. allargare la dimensione dello SWAP file","text":"<p><code>sudo dphys-swapfile swapoff</code></p> <p>edit /etc/dphys-swapfile</p> <p>```text    CONF_SWAPSIZE=8000</p> <p>CONF_MAXSWAP=8000    ```</p> <p>Riavviare servizio</p> <p><code>text    sudo dphys-swapfile setup    sudo dphys-swapfile swapon</code></p> <p>verificare <code>sudo swapon --show</code></p>"},{"location":"proxmoxonpi5/#1-gestire-i-backup-delle-vm-e-delle-ct","title":"1. gestire i backup delle VM e delle CT","text":"<ul> <li>shared Storage    aggiunta di storage NFS per l'archiviazione esterna dei backup</li> <li>Preparare la condivisione NFS su Synology vedere qui</li> <li><code>Datacenter/Storage/Add: NFS</code></li> <li> <p>Configurare</p> <p><code>text   ID: SynoNFS   Server: 192.168.1.250   Export: /volume1/proxmox   Content: Disk image, ISO image, Container template, VZDump backup file, Container</code></p> <p>--&gt; <code>Add</code></p> </li> <li> <p>attivare la cache locale per la creazione del backup    <code>nano /etc/vzdump.conf</code></p> </li> </ul> <p><code>text    # vzdump default settings    tmpdir: /tmp    #dumpdir: DIR    #storage: STORAGE_ID    ...</code></p>"},{"location":"proxmoxonpi5/#2-rendere-visibili-le-vmct-come-hostnamelocal-sulla-propria-rete-locale","title":"2. rendere visibili le VM/CT come [hostname].local sulla propria rete locale","text":"<ul> <li>install <code>avahi-daemon</code> package</li> </ul>"},{"location":"proxmoxonpi5/#3-pimox-scripts","title":"3. Pimox scripts","text":"<p>Proxmox arm64 Install Scripts</p>"},{"location":"proxmoxonpi5/#4-accorgimenti-per-far-funzionare-le-vm-arm64-anche-desktop-mode","title":"4. Accorgimenti per far funzionare le VM arm64 anche desktop mode","text":"<ul> <li>bios : OVMF (UEFI)</li> <li>initial DVD:SCSI / HD : SATA</li> <li>then NO DVD / HD (detach + reattach as SCSI0)</li> <li>Boot order (always to check)</li> <li>(some time with no display)</li> <li>if hangs on STOP or SHUTDOWN use \"Monitor\" then QUIT</li> </ul>"},{"location":"proxmoxonpi5/#5-aggiustare-dns-allinterno-di-ct-basate-su-debian-12","title":"5. Aggiustare DNS all'interno di CT (basate su debian 12)","text":"<ul> <li>verifica dns : <code>cat /etc/resolv.conf</code></li> <li>modifica il file con <code>nameserver 8.8.8.8</code></li> <li>riavvia il servizio <code>sudo systemctl restart systemd-resolved</code></li> </ul>"},{"location":"proxmoxonpi5/#6-montare-un-disco-esterno-su-proxmox-smb","title":"6. montare un disco esterno su proxmox (SMB)","text":"<p>Distinguiamo due differenti metodi per montare un disco: il primo pi\u00f9 \"storico\" \u00e8 mediante la configurazione del file <code>fstab</code>, l'altra, pi\u00f9 \"moderna\" utilizza <code>systemd</code>.</p> <ol> <li>creare la cartella per il punto di mount: <code>mkdir /media/wdbackup</code></li> <li>preparare un file con le credenziali di accesso alla risorsa condivisa : <code>nano /etc/win-credentials</code></li> </ol> <p><code>text    username=root    password=pass</code></p> <ol> <li>editare il file <code>/etc/fstab</code> ed aggiungere per esempio per una connessione SMB/cifs:</li> </ol> <p><code>text    //192.168.1.249/WDBackup /media/wdbackup cifs relatime,credentials=/etc/win-credentials,file_mode=0777,dir_mode=0777,x-systemd.automount 0 0</code></p> <p>questo dovrebbe montare in /media/wdbackup la condivisione WDBackup dal server 192.268.1.249, nota che in questo caso    seppur la condivisione fosse senza guest viene comunque usato un fake user e password</p> <p>In automatico <code>systemd</code> utilizza il file <code>fstab</code> per crearsi la configurazione di mount alla partenza. Vengono creati servizi con come mount-point.mount. Per l'esempio seguente viene creato il servizio <code>media-wdbackup.mount</code></p> <p>Quindi \u00e8 possibile verificare lo stato del sistema con il comando:</p> <pre><code>systemctl status media-wdbackup.mount\n</code></pre> <p>Sono possibili anche tutti i comandi disponibili con <code>systemctl</code> come <code>start</code>, <code>stop</code>, <code>restart</code> ...</p>"},{"location":"proxmoxonpi5/#7-condividere-cartelle-o-mount-da-proxmox-host-verso-ct","title":"7. condividere cartelle o mount da Proxmox host verso CT","text":"<ul> <li>per effettuare la condivisione di cartella (bindmount) eseguire il comando:</li> </ul> <p><code>bash    pct set 504 -mp0 /media/wdbackup,mp=/media/wdbackup</code></p> <p>in questo caso viene condivisa la cartella /media/wdbackup sulla CT in /media/wdbackup con is mp0.    ATTENZIONE: la CT deve essere definita \"priviledged\" altrimenti \u00e8 impossibile utilizzare la cartella in scrittura.</p>"},{"location":"proxmoxonpi5/#8-convertire-una-ct-da-unpriviledged-to-priviledged-o-viceversa","title":"8. convertire una CT da unpriviledged to priviledged o viceversa","text":"<p>Effettuare backup della CT    Effettuare il restore scegliendo l'opzione scelta.</p>"},{"location":"proxmoxonpi5/#9-creare-una-partizione-lvm-thin-partendo-da-un-disco-full-ext4","title":"9. Creare una partizione LVM-Thin partendo da un disco full ext4","text":"<p>Se si dispone di aree di SSD non partizionate allora \u00e8 possibile procedere alla creazione di una partizione LVM</p> <ul> <li>usare <code>fdisk</code> per creare la nuova partizione di tipo LVM</li> </ul> <p>Si procede alla creazione della nuova partizione sfruttando    lo spazio liberato.</p> <p><code>fdisk /dev/nvme0n1</code> per entrare nell'utility di formattazione</p> <p><code>F</code> per visualizzare gli spazi non partizionati. Potrebbero    essere listati pi\u00f9 spazi in quanto spesso per questioni di allineamento    rimangono anche piccoli spazi disco non partizionabili.    Appuntarsi i valori di Start ed End dello spazio che    si deve utilizzare.</p> <p><code>n</code> creare la nuova partizione: tipo primary, numero della    partizione e start e end appuntati precedentemente.</p> <p><code>t</code> per cambiare il formato della partizione in <code>8e</code> LVM</p> <p><code>w</code> scrive le modifiche su disco (con <code>q</code> si esce senza modificare)</p> <ul> <li>creazione del \"Thinpool\"    Da interfaccia web, selezionare la voce <code>Disks\\LVM-Thin</code> del nodo.    Selezionare la voce <code>Create:Thinpool</code> e da popup configurare:<ul> <li>Disk: selezionata in automatico la partizione formattata in LVM</li> <li>Name: local-lvm</li> <li>Add Storage: selezionato</li> </ul> </li> </ul>"},{"location":"proxmoxonpi5/#10-tailscale-non-funziona-allinterno-di-una-lxc","title":"10. Tailscale non funziona all'interno di una LXC","text":"<p>Potrebbe essere necessario installare <code>tailscale</code> all'interno di un LXC. Pu\u00f2 succedere che dopo aver seguito la procedura indicata nel sito ufficiale di Tailscale al momento di lanciare il comando <code>tailscale up</code> il sistema indichi un errore.</p> <p>Questo \u00e8 dovuto al fatto che il sistema non \u00e8 in grado di essere instanziato come servizio per incompatibilit\u00e0 della struttura: non riesce a trovare il percorso /dev/net</p> <p>La soluzione consiste nel modificare a mano il file di configurazione del LXC.</p> <p>Dalla console comandi della macchina Proxmox spostarsi nella cartella <code>/etc/pve/lxc</code> e editare il file relativo alla CT sulla quale si riscontra il problema: ad esempio <code>303.conf</code></p> <p>Aggiungere in fondo al file le seguenti due linee:</p> <pre><code>lxc.cgroup2.devices.allow: c 10:200 rwm\nlxc.mount.entry: /dev/net dev/net none bind,create=dir\n</code></pre> <p>Salvare e riavviare la CT.</p> <p>Ora il comando <code>tailscale up</code> dovrebbe funzionare.</p>"},{"location":"raspi5nvme/","title":"Raspberry Pi 5 con SSD NVMe","text":"<p>[documento editato il 2024-08-30]</p> <p>Sono qui raccolte le operazione seguite per la preparazione del mio Homelab su base Raspberry Pi 5.</p> <p>Materiali utilizzati:</p> Raspberry Pi 5 8GB Quad-Core ARMA76 (64 Bits - 2,4 GHz) acquista su Amazon.it Alimentatore Raspberry Pi 5 USB-C da 27W acquista su Amazon.it Argon NEO 5 M.2 NVME PCIE Case for Raspberry Pi 5 acquista su Amazon.it Crucial P3 500GB PCIe M.2 2280 SSD acquista su Amazon.it Twozoh Adattatore Micro HDMI a HDMI acquista su Amazon.it <p>Solo per uso temporaneo occorre anche avere a disposizione un scheda di memoria microSD della capacit\u00e0 di almeno 8Gb, nonch\u00e8 un monitor HDMI e un mouse USB e tastiera USB.</p> <p>La preparazione dell'hardware non necessita di particolari istruzione, l'unico accorgimento \u00e8 quello di evitare di chiudere il case fino a quando l'installazione su memoria SSD non \u00e8 stata terminata e correttamente verificata.</p> <p>Nota</p> <p>Il case non prevede l'accesso alla scheda microSD, quindi occorre terminare tutte le operazioni che la prevedano prima di estrarla e poi chiudere il case.</p>"},{"location":"raspi5nvme/#installazione-del-sistema-operativo-su-memoria-ssd","title":"Installazione del sistema operativo su memoria SSD","text":"<p>Se si ha a disposizione un adattatore per schede M.2 NVMe allora \u00e8 possibile effettuare l'installazione del sistema operativo direttamente sulla scheda di memoria.</p> <p>Personalmnete non avendo a disposizione questo adattatore ho preferito effettuare l'operazione di scrittura direttamente tramite la Raspberry Pi 5.</p> <p>In linea di massima si consiglia di seguire le seguenti operazioni:</p> <ol> <li>Scaricare l'applicativo Raspberry Pi Imager adatto al proprio Sistema Operativo.</li> <li>Tramite Raspberry Pi Imager programmare la scheda microSD con il SO Raspberry Pi OS (64bit)</li> <li>Inserire la microSD nella Pi 5 e assicurarsi inoltre di avere inserito anche la memoria NVMe.</li> <li>Avviare il Raspberry Pi 5 da microSD. Da applicazione Desktop assicurarsi di avere a    disposizione l'applicativo Raspberry Pi Imager</li> <li>Utilizzare Raspberry Pi Imager da desktop su Pi 5 per programmare la memoria NVMe con il sistema operativo scelto.</li> </ol> <p>Nota</p> <p>tramite Raspberry Pi Imager \u00e8 possibile predisporre alcune personalizzazioni per il sistema, consiglio di: - impostare username e password - settare rete WiFi - abilitare il servizio SSH per l'accesso remoto - impostare timezone e layout tastiera</p> <ol> <li>Accertarsi che al prossimo riavvio il sistema utilizzi NVMe come boot disk: da    terminale lanciare <code>sudo raspi-config</code>, poi da menu <code>Advanced Options</code> -&gt; <code>Boot Order</code>.    Qui assicurarsi di utilizzare una opzione che permetta il boot da NVMe/USB in assenza    di microSD (nel mio caso \u00e8 la selezione di default).</li> </ol> <p>L'installazione non \u00e8 completata: al primo avvio parte una procedura di installazione e configurazione che utilizzer\u00e0 tutto il disco,e effettuer\u00e0 tutte le configurazioni iniziali.</p> <p>Una volta terminata la procedura si presenta il terminale per poter effettuare login.</p>"},{"location":"raspi5nvme/#riduzione-della-partizione-esistente","title":"Riduzione della partizione esistente","text":"<p>Se l'SSD utilizzato ha una dimensione sufficiente \u00e8 consigliato ridurre la partizione principale permettendo cos\u00ec di formattare una parte dell'SSD con filesystem pi\u00f9 opportuni, ad esempio per creare una partizione LVM utile per ottenere una allocazione dinamica dei volumi.</p> <p>Per effettuare la riduzione della partizione in modo indolore \u00e8 consigliato effettuarlo con partizione non montata. Questo \u00e8 impossibile bootstrappando da SSD, quindi andremo a riavviare il Raspberry utilizzando la scheda SD utilizzata in fase di installazione.</p> <p>Installare il pacchetto \"Partition Manager KDE\" (o in alternativa GParted)</p> <p>Tramite l'interfaccia grafica e facile effettuare la riduzione della partizione. In questo modo lasceremo dello spazio non partizionato che potremo utilizzare di seguito in base alle esigenze.</p> <p>Nel mio caso ho scelto di mantenere 125GB (128000MB) come pertizione ext4.</p> <p>Procedere salvando la nuova partizione e riavviando il sistema senza la scheda SD.</p>"}]}